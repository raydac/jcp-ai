[
  {
    "uuid": "8efd6186-7209-4b96-9b6d-5c2206a905ca",
    "instant": "2025-07-15T22:04:03.261603357Z",
    "key": "fAq/2m/NmN8brRzAfUwCOg\u003d\u003d",
    "result": "/**\n * Sorts an array of integers using the HeapSort algorithm, prioritizing speed and minimal memory overhead.\n * This method implements the entire sorting logic within a single function without relying on external\n * helper methods or utility classes, as per the requirements.\n * \u003cp\u003e\n * The method handles edge cases:\n * \u003cul\u003e\n *     \u003cli\u003eIf the input array is {@code null}, it returns {@code null}.\u003c/li\u003e\n *     \u003cli\u003eIf the input array is empty or contains a single element, it returns the same array instance.\u003c/li\u003e\n *     \u003cli\u003eOtherwise, it returns a new array instance containing the sorted values.\u003c/li\u003e\n * \u003c/ul\u003e\n * The sorting process itself operates in-place on a copy of the array, ensuring O(1) auxiliary space complexity\n * for the sort (excluding the initial O(N) copy required by the return specification).\n * The time complexity is O(N log N) in all cases (best, average, and worst).\n *\n * @param array The array of integers to be sorted.\n * @param asc   If {@code true}, the array will be sorted in ascending order; otherwise, in descending order.\n * @return A new array instance with sorted values, or the original array/null for edge cases.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    // Handle edge cases: null, empty, or single-element array\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) {\n        return array;\n    }\n\n    // Create a new array to store the sorted result, as per requirement to return a new array\n    int[] result \u003d new int[array.length];\n    for (int i \u003d 0; i \u003c array.length; i++) {\n        result[i] \u003d array[i];\n    }\n\n    int n \u003d result.length;\n\n    // Phase 1: Build a max-heap from the array (heapify)\n    // Iterate from the last non-leaf node up to the root (index 0)\n    for (int i \u003d n / 2 - 1; i \u003e\u003d 0; i--) {\n        // Inlined sift-down operation for the node at index \u0027i\u0027\n        int k \u003d i; // Current node index being sifted down\n        while (true) {\n            int leftChild \u003d 2 * k + 1;\n            int rightChild \u003d 2 * k + 2;\n            int largest \u003d k; // Assume current node is the largest\n\n            // Check if left child exists within the heap and is greater than current largest\n            if (leftChild \u003c n \u0026\u0026 result[leftChild] \u003e result[largest]) {\n                largest \u003d leftChild;\n            }\n\n            // Check if right child exists within the heap and is greater than current largest\n            if (rightChild \u003c n \u0026\u0026 result[rightChild] \u003e result[largest]) {\n                largest \u003d rightChild;\n            }\n\n            // If the largest element is not the current node, swap them and continue sifting down\n            if (largest !\u003d k) {\n                int temp \u003d result[k];\n                result[k] \u003d result[largest];\n                result[largest] \u003d temp;\n                k \u003d largest; // Move down to the child that was swapped\n            } else {\n                break; // Node k is in its correct heap position; stop sifting\n            }\n        }\n    }\n\n    // Phase 2: Extract elements one by one from the heap\n    // The largest element (root) is swapped with the last element of the heap,\n    // and the heap size is reduced. Then, the new root is sifted down.\n    for (int i \u003d n - 1; i \u003e 0; i--) {\n        // Move the current root (which is the largest element) to the end of the unsorted part\n        int temp \u003d result[0];\n        result[0] \u003d result[i];\n        result[i] \u003d temp;\n\n        // Inlined sift-down operation for the new root (index 0) on the reduced heap\n        // The heap size for this operation is now \u0027i\u0027 (elements from 0 to i-1)\n        int k \u003d 0; // Current node index (root of the reduced heap)\n        while (true) {\n            int leftChild \u003d 2 * k + 1;\n            int rightChild \u003d 2 * k + 2;\n            int largest \u003d k; // Assume current node is the largest\n\n            // Check if left child exists within the reduced heap and is greater\n            if (leftChild \u003c i \u0026\u0026 result[leftChild] \u003e result[largest]) {\n                largest \u003d leftChild;\n            }\n\n            // Check if right child exists within the reduced heap and is greater\n            if (rightChild \u003c i \u0026\u0026 result[rightChild] \u003e result[largest]) {\n                largest \u003d rightChild;\n            }\n\n            // If the largest element is not the current node, swap them and continue sifting down\n            if (largest !\u003d k) {\n                int temp2 \u003d result[k];\n                result[k] \u003d result[largest];\n                result[largest] \u003d temp2;\n                k \u003d largest; // Move down to the child that was swapped\n            } else {\n                break; // Node k is in its correct heap position; stop sifting\n            }\n        }\n    }\n\n    // Phase 3: Adjust order if descending is required\n    // HeapSort naturally sorts in ascending order (after extraction, largest elements are at the end).\n    // If descending order is requested, the array needs to be reversed.\n    if (!asc) {\n        for (int i \u003d 0; i \u003c n / 2; i++) {\n            int temp \u003d result[i];\n            result[i] \u003d result[n - 1 - i];\n            result[n - 1 - i] \u003d temp;\n        }\n    }\n\n    return result;\n}",
    "fileName": "ArraySorter.java",
    "line": 5
  }
]