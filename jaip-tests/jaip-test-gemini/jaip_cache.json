[{
  "uuid": "19052d68-ba0b-4af4-8c3b-138ed19a990d",
  "instant": "2025-07-20T12:02:42.245698866Z",
  "key": "xXSDlFqXa/SznNrHu8Id98R9+WfV04tMwVyp6YFTFn64/RyPwUN/kHNvocC/l/GWE4PniTp3tE/d8oUiA0vNO0qgn2hx4mpb7mKMTv1NS4Y=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts an array of integers using an iterative Quicksort algorithm.\n * This method prioritizes speed and minimal memory overhead.\n * It returns a new sorted array, leaving the original array unchanged,\n * unless the input array is null, empty, or contains a single element,\n * in which case the original array is returned directly.\n *\n * @param array The array of integers to be sorted.\n * @param asc   If true, sorts in ascending order; otherwise, sorts in descending order.\n * @return A new array with sorted values, or the original array if it's null, empty, or single-valued.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int[] result = new int[array.length];\n    java.lang.System.arraycopy(array, 0, result, 0, array.length);\n\n    // Custom stack for iterative Quicksort.\n    // By always pushing the smaller partition first, the stack depth is guaranteed to be O(log N).\n    // A stack size of 128 (64 pairs of low/high indices) is sufficient for practical array sizes.\n    int[] stack = new int[128];\n    int top = -1;\n\n    // Push the initial range (entire array) onto the stack\n    stack[++top] = 0;\n    stack[++top] = result.length - 1;\n\n    while (top >= 0) {\n        // Pop the current range to be sorted\n        int high = stack[top--];\n        int low = stack[top--];\n\n        if (low < high) {\n            // Choose the last element as the pivot (Lomuto partition scheme)\n            int pivot = result[high];\n            int i = low - 1;\n\n            // Partition the array around the pivot\n            for (int j = low; j < high; j++) {\n                if (asc ? (result[j] <= pivot) : (result[j] >= pivot)) {\n                    i++;\n                    int temp = result[i];\n                    result[i] = result[j];\n                    result[j] = temp;\n                }\n            }\n\n            // Place the pivot in its correct sorted position\n            int temp = result[i + 1];\n            result[i + 1] = result[high];\n            result[high] = temp;\n            int partitionIndex = i + 1;\n\n            // Push sub-arrays to the stack, always pushing the smaller partition first\n            // This ensures O(log N) stack space, preventing stack overflow for large arrays.\n            if (partitionIndex - low < high - partitionIndex) {\n                // Left partition is smaller, push it first\n                if (low < partitionIndex - 1) {\n                    stack[++top] = low;\n                    stack[++top] = partitionIndex - 1;\n                }\n                // Then push the right partition\n                if (partitionIndex + 1 < high) {\n                    stack[++top] = partitionIndex + 1;\n                    stack[++top] = high;\n                }\n            } else {\n                // Right partition is smaller or equal, push it first\n                if (partitionIndex + 1 < high) {\n                    stack[++top] = partitionIndex + 1;\n                    stack[++top] = high;\n                }\n                // Then push the left partition\n                if (low < partitionIndex - 1) {\n                    stack[++top] = low;\n                    stack[++top] = partitionIndex - 1;\n                }\n            }\n        }\n    }\n\n    return result;\n}"
}]