[{
  "uuid": "815de2fa-9ad7-4705-9c9c-08eb3a7cef49",
  "instant": "2025-07-21T08:43:49.077919324Z",
  "key": "xXSDlFqXa/SznNrHu8Id98R9+WfV04tMwVyp6YFTFn64/RyPwUN/kHNvocC/l/GWE4PniTp3tE/d8oUiA0vNO0qgn2hx4mpb7mKMTv1NS4Y=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts an array of integers using an optimized iterative Quicksort algorithm.\n * This method prioritizes speed and uses minimal memory overhead.\n * It handles null, empty, or single-element arrays by returning the original array.\n * For other arrays, it returns a new sorted array.\n *\n * @param array The array to be sorted.\n * @param asc   If true, sorts in ascending order; otherwise, sorts in descending order.\n * @return A new array with sorted values, or the original array if it's null, empty, or single-valued.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int[] sortedArray = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        sortedArray[i] = array[i];\n    }\n\n    int[] stack = new int[128];\n    int sp = 0;\n\n    stack[sp++] = 0;\n    stack[sp++] = sortedArray.length - 1;\n\n    while (sp > 0) {\n        int right = stack[--sp];\n        int left = stack[--sp];\n\n        if (right - left < 27) {\n            for (int i = left + 1; i <= right; i++) {\n                int current = sortedArray[i];\n                int j = i - 1;\n                if (asc) {\n                    while (j >= left && sortedArray[j] > current) {\n                        sortedArray[j + 1] = sortedArray[j];\n                        j--;\n                    }\n                } else {\n                    while (j >= left && sortedArray[j] < current) {\n                        sortedArray[j + 1] = sortedArray[j];\n                        j--;\n                    }\n                }\n                sortedArray[j + 1] = current;\n            }\n            continue;\n        }\n\n        int pLeft = left;\n        int pRight = right;\n        int pMid = left + (right - left) / 2;\n\n        if (asc) {\n            if (sortedArray[pLeft] > sortedArray[pMid]) { int temp = sortedArray[pLeft]; sortedArray[pLeft] = sortedArray[pMid]; sortedArray[pMid] = temp; }\n            if (sortedArray[pLeft] > sortedArray[pRight]) { int temp = sortedArray[pLeft]; sortedArray[pLeft] = sortedArray[pRight]; sortedArray[pRight] = temp; }\n            if (sortedArray[pMid] > sortedArray[pRight]) { int temp = sortedArray[pMid]; sortedArray[pMid] = sortedArray[pRight]; sortedArray[pRight] = temp; }\n        } else {\n            if (sortedArray[pLeft] < sortedArray[pMid]) { int temp = sortedArray[pLeft]; sortedArray[pLeft] = sortedArray[pMid]; sortedArray[pMid] = temp; }\n            if (sortedArray[pLeft] < sortedArray[pRight]) { int temp = sortedArray[pLeft]; sortedArray[pLeft] = sortedArray[pRight]; sortedArray[pRight] = temp; }\n            if (sortedArray[pMid] < sortedArray[pRight]) { int temp = sortedArray[pMid]; sortedArray[pMid] = sortedArray[pRight]; sortedArray[pRight] = temp; }\n        }\n\n        int pivotValue = sortedArray[pMid];\n        int temp = sortedArray[pMid]; sortedArray[pMid] = sortedArray[pRight - 1]; sortedArray[pRight - 1] = temp;\n\n        int i = pLeft;\n        int j = pRight - 1;\n\n        while (true) {\n            if (asc) {\n                while (sortedArray[++i] < pivotValue);\n                while (sortedArray[--j] > pivotValue);\n            } else {\n                while (sortedArray[++i] > pivotValue);\n                while (sortedArray[--j] < pivotValue);\n            }\n\n            if (i >= j) {\n                break;\n            }\n            temp = sortedArray[i]; sortedArray[i] = sortedArray[j]; sortedArray[j] = temp;\n        }\n\n        temp = sortedArray[i]; sortedArray[i] = sortedArray[pRight - 1]; sortedArray[pRight - 1] = temp;\n        int pivotFinalIndex = i;\n\n        if (pivotFinalIndex - pLeft > pRight - pivotFinalIndex) {\n            stack[sp++] = pLeft;\n            stack[sp++] = pivotFinalIndex - 1;\n            stack[sp++] = pivotFinalIndex + 1;\n            stack[sp++] = pRight;\n        } else {\n            stack[sp++] = pivotFinalIndex + 1;\n            stack[sp++] = pRight;\n            stack[sp++] = pLeft;\n            stack[sp++] = pivotFinalIndex - 1;\n        }\n    }\n\n    return sortedArray;\n}"
}]