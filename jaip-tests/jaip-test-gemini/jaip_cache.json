[
  {
    "uuid": "21fde91f-32d7-49ab-881d-f6cece43dcab",
    "instant": "2025-07-16T09:16:17.214654836Z",
    "key": "LQ8wr+gtp+hMPxC7X3ydbVjRjqCxoII5QeMdIFh+gJuIsDNc+2zBVS1PmK2vaTZz0wcc+G8fuAkzErpZbjICBg\u003d\u003d",
    "result": "/**\n * Sorts an array of integers using the HeapSort algorithm.\n * This method prioritizes speed and minimal memory overhead.\n * It handles null, empty, or single-value arrays by returning the original array.\n * For arrays with more than one element, it returns a new array containing the sorted values.\n * The sorting order (ascending or descending) is determined by the \u0027asc\u0027 flag.\n * All implementation details, including the sort algorithm, are contained within this single method\n * without the use of any external libraries, helper methods, or utility classes (beyond core language constructs).\n *\n * @param array The array of integers to be sorted.\n * @param asc   If true, the array will be sorted in ascending order; otherwise, in descending order.\n * @return The same incoming array if it is null, empty, or a single-value array;\n *         otherwise, a new array with the sorted values.\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) {\n        return array;\n    }\n\n    int[] sortedArray \u003d new int[array.length];\n    for (int i \u003d 0; i \u003c array.length; i++) {\n        sortedArray[i] \u003d array[i];\n    }\n\n    int n \u003d sortedArray.length;\n\n    for (int i \u003d n / 2 - 1; i \u003e\u003d 0; i--) {\n        int k \u003d i;\n        int val \u003d sortedArray[k];\n\n        while (k * 2 + 1 \u003c n) {\n            int child \u003d k * 2 + 1;\n\n            if (child + 1 \u003c n) {\n                if (asc) {\n                    if (sortedArray[child] \u003c sortedArray[child + 1]) {\n                        child++;\n                    }\n                } else {\n                    if (sortedArray[child] \u003e sortedArray[child + 1]) {\n                        child++;\n                    }\n                }\n            }\n\n            boolean swapNeeded;\n            if (asc) {\n                swapNeeded \u003d val \u003c sortedArray[child];\n            } else {\n                swapNeeded \u003d val \u003e sortedArray[child];\n            }\n\n            if (swapNeeded) {\n                sortedArray[k] \u003d sortedArray[child];\n                k \u003d child;\n            } else {\n                break;\n            }\n        }\n        sortedArray[k] \u003d val;\n    }\n\n    for (int i \u003d n - 1; i \u003e 0; i--) {\n        int temp \u003d sortedArray[0];\n        sortedArray[0] \u003d sortedArray[i];\n        sortedArray[i] \u003d temp;\n\n        int k \u003d 0;\n        int val \u003d sortedArray[k];\n        int currentHeapSize \u003d i;\n\n        while (k * 2 + 1 \u003c currentHeapSize) {\n            int child \u003d k * 2 + 1;\n\n            if (child + 1 \u003c currentHeapSize) {\n                if (asc) {\n                    if (sortedArray[child] \u003c sortedArray[child + 1]) {\n                        child++;\n                    }\n                } else {\n                    if (sortedArray[child] \u003e sortedArray[child + 1]) {\n                        child++;\n                    }\n                }\n            }\n\n            boolean swapNeeded;\n            if (asc) {\n                swapNeeded \u003d val \u003c sortedArray[child];\n            } else {\n                swapNeeded \u003d val \u003e sortedArray[child];\n            }\n\n            if (swapNeeded) {\n                sortedArray[k] \u003d sortedArray[child];\n                k \u003d child;\n            } else {\n                break;\n            }\n        }\n        sortedArray[k] \u003d val;\n    }\n\n    return sortedArray;\n}",
    "fileName": "ArraySorter.java",
    "line": 5
  }
]