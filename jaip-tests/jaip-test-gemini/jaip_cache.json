[
  {
    "uuid": "39407df7-0700-43a0-833a-ae2116f8b316",
    "instant": "2025-07-18T08:34:52.855648980Z",
    "key": "ULW6+gT8gdk4dUlxR/Vhoj6NqCi5k60A8tuCHugfK5idNDEocav/IGDXfRG96oVLxKnfkYyhCWttwRN1xYlJ5/hhClPtmD3gZziGsG9iB1c\u003d",
    "result": "/**\n * Sorts an integer array using a fast, in-place sorting algorithm with minimal memory overhead.\n * The chosen algorithm is Heapsort, which offers O(N log N) time complexity in all cases\n * (best, average, worst) and O(1) auxiliary space complexity for the sorting process itself.\n *\n * \u003cp\u003eSpecial handling for input array:\n * \u003cul\u003e\n *     \u003cli\u003eIf the input array is null, empty, or contains a single value, the original array is returned directly.\u003c/li\u003e\n *     \u003cli\u003eOtherwise, a new array containing the sorted values is returned, ensuring the original array remains unchanged.\u003c/li\u003e\n * \u003c/ul\u003e\n *\n * \u003cp\u003eThe method implements the entire sort algorithm internally without relying on external libraries,\n * helper methods, or utility classes beyond core language constructs and array operations.\n * All logic is contained within this single method, without any internal comments.\n *\n * @param array The integer array to be sorted. This array is not modified if a new array is returned.\n * @param asc   If true, the array is sorted in ascending order; otherwise, in descending order.\n * @return A new array with sorted values, or the original array if it\u0027s null, empty, or single-valued.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) {\n        return array;\n    }\n\n    int[] result \u003d new int[array.length];\n    System.arraycopy(array, 0, result, 0, array.length);\n\n    int n \u003d result.length;\n\n    // Phase 1: Build a max-heap from the array elements.\n    // This loop iterates from the last non-leaf node up to the root (index 0).\n    for (int i \u003d n / 2 - 1; i \u003e\u003d 0; i--) {\n        // Sift-down operation (heapify) for the element at index i.\n        // This ensures the subtree rooted at i satisfies the max-heap property.\n        int k \u003d i;\n        int v \u003d result[k];\n        int limit \u003d n;\n\n        while (k * 2 + 1 \u003c limit) {\n            int j \u003d k * 2 + 1; // Index of the left child\n\n            if (j + 1 \u003c limit \u0026\u0026 result[j] \u003c result[j + 1]) {\n                j++; // If right child exists and is larger, use right child\n            }\n\n            if (v \u003e\u003d result[j]) {\n                break; // Current node is already larger than or equal to its largest child\n            }\n\n            result[k] \u003d result[j]; // Move the larger child up\n            k \u003d j; // Move down to the child\u0027s position\n        }\n        result[k] \u003d v; // Place the original value in its correct position\n    }\n\n    // Phase 2: Extract elements from the heap one by one to sort the array.\n    // The largest element (root) is swapped with the last element of the unsorted portion,\n    // and then the heap is re-heapified for the reduced size.\n    for (int i \u003d n - 1; i \u003e 0; i--) {\n        // Swap the root (largest element) with the current last element of the unsorted portion.\n        int temp \u003d result[0];\n        result[0] \u003d result[i];\n        result[i] \u003d temp;\n\n        // Sift-down the new root into the remaining heap (which has a reduced size \u0027i\u0027).\n        int k \u003d 0;\n        int v \u003d result[k];\n        int limit \u003d i;\n\n        while (k * 2 + 1 \u003c limit) {\n            int j \u003d k * 2 + 1; // Index of the left child\n\n            if (j + 1 \u003c limit \u0026\u0026 result[j] \u003c result[j + 1]) {\n                j++; // If right child exists and is larger, use right child\n            }\n\n            if (v \u003e\u003d result[j]) {\n                break; // Current node is already larger than or equal to its largest child\n            }\n\n            result[k] \u003d result[j]; // Move the larger child up\n            k \u003d j; // Move down to the child\u0027s position\n        }\n        result[k] \u003d v; // Place the original value in its correct position\n    }\n\n    // Phase 3: If descending order is required, reverse the ascendingly sorted array.\n    if (!asc) {\n        for (int i \u003d 0; i \u003c n / 2; i++) {\n            int temp \u003d result[i];\n            result[i] \u003d result[n - 1 - i];\n            result[n - 1 - i] \u003d temp;\n        }\n    }\n\n    return result;\n}",
    "fileName": "ArraySorter.java",
    "line": 5
  }
]