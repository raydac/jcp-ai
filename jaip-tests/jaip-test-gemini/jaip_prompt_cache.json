[
  {
    "uuid": "ad9dd9f6-0f3c-4b03-b420-05026f7b08b1",
    "instant": "2025-07-15T19:03:57.684455543Z",
    "key": "JRqYSsRZLLwe297ldhG33g\u003d\u003d",
    "result": "/**\n * Sorts an array of integers using an optimized iterative QuickSort algorithm.\n * This implementation aims for speed and minimal memory overhead, considering\n * the requirement to return a new array for non-trivial inputs.\n * It incorporates median-of-three pivot selection and switches to Insertion Sort\n * for small sub-arrays to improve performance. It uses an explicit stack to\n * manage sub-problems, ensuring O(log N) stack depth in the average and worst case.\n *\n * The algorithm is implemented entirely within this single method, without\n * any additional helper methods, utility classes (like `java.util.Arrays` or `java.util.Deque`),\n * or third-party libraries.\n *\n * @param array The array to be sorted.\n * @param asc   If true, sort in ascending order; otherwise, sort in descending order.\n * @return The same incoming array if it is null, empty, or contains a single value.\n *         Otherwise, returns a new array with the sorted values.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    // Handle base cases: null, empty, or single-element arrays\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) {\n        return array;\n    }\n\n    // Create a new array for the sorted result, as per requirement\n    int[] result \u003d new int[array.length];\n    System.arraycopy(array, 0, result, 0, array.length);\n\n    // Threshold for switching to Insertion Sort for small sub-arrays\n    // A common value is 7-15. 16 is chosen for good performance.\n    final int INSERTION_SORT_THRESHOLD \u003d 16;\n\n    // Manual stack for storing (low, high) index pairs for QuickSort partitions.\n    // Max stack depth for QuickSort with optimized pushing (always process smaller partition)\n    // is O(log N). For N up to Integer.MAX_VALUE, log2(N) is approx 31.\n    // So, 2 * 32 \u003d 64 elements for low/high pairs should be sufficient.\n    int[] stack \u003d new int[2 * 64];\n    int top \u003d -1; // Stack pointer\n\n    // Push the initial range onto the stack\n    stack[++top] \u003d 0;\n    stack[++top] \u003d result.length - 1;\n\n    // Main loop: Process ranges from the stack\n    while (top \u003e\u003d 0) {\n        int high \u003d stack[top--];\n        int low \u003d stack[top--];\n\n        // Inner loop for processing the current range (iterative QuickSort)\n        while (low \u003c high) {\n            // If the sub-array is small, use Insertion Sort\n            if (high - low + 1 \u003c INSERTION_SORT_THRESHOLD) {\n                for (int i \u003d low + 1; i \u003c\u003d high; i++) {\n                    int key \u003d result[i];\n                    int j \u003d i - 1;\n                    if (asc) {\n                        while (j \u003e\u003d low \u0026\u0026 result[j] \u003e key) {\n                            result[j + 1] \u003d result[j];\n                            j--;\n                        }\n                    } else { // descending\n                        while (j \u003e\u003d low \u0026\u0026 result[j] \u003c key) {\n                            result[j + 1] \u003d result[j];\n                            j--;\n                        }\n                    }\n                    result[j + 1] \u003d key;\n                }\n                break; // Sub-array sorted, break inner loop and get next range from stack\n            }\n\n            // QuickSort Partitioning\n            // Choose pivot using median-of-three strategy to avoid worst-case O(N^2)\n            // Sort result[low], result[mid], result[high] in place to put median at result[mid]\n            int mid \u003d low + (high - low) / 2;\n\n            // Sort low, mid, high elements based on `asc` flag\n            // This ensures result[low] \u003c\u003d result[mid] \u003c\u003d result[high] (or reverse for descending)\n            // after these three comparisons and potential swaps.\n            if (asc) {\n                if (result[low] \u003e result[mid]) { int temp \u003d result[low]; result[low] \u003d result[mid]; result[mid] \u003d temp; }\n                if (result[low] \u003e result[high]) { int temp \u003d result[low]; result[low] \u003d result[high]; result[high] \u003d temp; }\n                if (result[mid] \u003e result[high]) { int temp \u003d result[mid]; result[mid] \u003d result[high]; result[high] \u003d temp; }\n            } else { // descending\n                if (result[low] \u003c result[mid]) { int temp \u003d result[low]; result[low] \u003d result[mid]; result[mid] \u003d temp; }\n                if (result[low] \u003c result[high]) { int temp \u003d result[low]; result[low] \u003d result[high]; result[high] \u003d temp; }\n                if (result[mid] \u003c result[high]) { int temp \u003d result[mid]; result[mid] \u003d result[high]; result[high] \u003d temp; }\n            }\n\n            // Now, result[mid] holds the median value.\n            // Swap median (at result[mid]) with result[high] to use it as the pivot for Lomuto partition.\n            int temp \u003d result[mid];\n            result[mid] \u003d result[high];\n            result[high] \u003d temp;\n            int pivotValue \u003d result[high];\n\n            // Lomuto partition scheme\n            int i \u003d low - 1; // Index of smaller element\n            for (int j \u003d low; j \u003c high; j++) {\n                if (asc) {\n                    if (result[j] \u003c\u003d pivotValue) {\n                        i++;\n                        // Swap result[i] and result[j]\n                        temp \u003d result[i];\n                        result[i] \u003d result[j];\n                        result[j] \u003d temp;\n                    }\n                } else { // descending\n                    if (result[j] \u003e\u003d pivotValue) {\n                        i++;\n                        // Swap result[i] and result[j]\n                        temp \u003d result[i];\n                        result[i] \u003d result[j];\n                        result[j] \u003d temp;\n                    }\n                }\n            }\n\n            // Swap result[i+1] and result[high] (pivot)\n            temp \u003d result[i + 1];\n            result[i + 1] \u003d result[high];\n            result[high] \u003d temp;\n\n            int pivotIndex \u003d i + 1;\n\n            // Push the larger partition onto the stack and continue with the smaller one.\n            // This ensures O(log N) stack depth.\n            if (pivotIndex - low \u003c high - pivotIndex) { // Left partition is smaller\n                stack[++top] \u003d pivotIndex + 1; // Push right partition\u0027s low\n                stack[++top] \u003d high;           // Push right partition\u0027s high\n                high \u003d pivotIndex - 1;         // Continue with left partition\n            } else { // Right partition is smaller or equal\n                stack[++top] \u003d low;            // Push left partition\u0027s low\n                stack[++top] \u003d pivotIndex - 1; // Push left partition\u0027s high\n                low \u003d pivotIndex + 1;          // Continue with right partition\n            }\n        }\n    }\n\n    return result;\n}"
  }
]