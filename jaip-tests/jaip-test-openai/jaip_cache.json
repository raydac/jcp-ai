[{
  "uuid": "98b86646-788e-4840-96c6-a58fd1772a08",
  "instant": "2025-07-20T12:03:20.407997933Z",
  "key": "xXSDlFqXa/SznNrHu8Id98R9+WfV04tMwVyp6YFTFn64/RyPwUN/kHNvocC/l/GWE4PniTp3tE/d8oUiA0vNO0qgn2hx4mpb7mKMTv1NS4Y=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts a given integer array in ascending or descending order with priority on speed and minimal memory overhead.\n * Returns the same array if it is null, empty, or single-valued; otherwise, returns a newly sorted array.\n * Uses in-place dual-pivot quicksort for best typical performance without auxiliary memory, as in the Java standard.\n *\n * @param array the array to sort\n * @param asc   true for ascending, false for descending order\n * @return      a sorted array, or the same array if null/empty/length == 1\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array == null || array.length < 2) return array;\n    int[] a = new int[array.length];\n    System.arraycopy(array, 0, a, 0, array.length);\n    int left = 0, right = a.length - 1;\n    java.util.ArrayDeque<int[]> stack = new java.util.ArrayDeque<>();\n    stack.push(new int[]{left, right});\n    while (!stack.isEmpty()) {\n        int[] bounds = stack.pop();\n        int lo = bounds[0], hi = bounds[1];\n        if (hi - lo < 27) {\n            for (int i = lo + 1; i <= hi; i++) {\n                int v = a[i], j = i - 1;\n                while (j >= lo && (asc ? a[j] > v : a[j] < v)) {\n                    a[j + 1] = a[j];\n                    j--;\n                }\n                a[j + 1] = v;\n            }\n            continue;\n        }\n        int seventh = (hi - lo + 1) / 7;\n        int e1 = lo + seventh;\n        int e2 = e1 + seventh;\n        int e3 = e2 + seventh;\n        int e4 = e3 + seventh;\n        int e5 = e4 + seventh;\n        int[] idx = asc ? new int[]{lo, e1, e2, e3, e4, e5, hi} : new int[]{hi, e5, e4, e3, e2, e1, lo};\n        int[] pv = new int[3];\n        pv[0] = a[idx[1]];\n        pv[1] = a[idx[3]];\n        pv[2] = a[idx[5]];\n        java.util.Arrays.sort(pv);\n        int pivot1 = pv[0], pivot2 = pv[2];\n        int less = lo, great = hi;\n        if (asc ? pivot1 == pivot2 : pivot1 == pivot2) {\n            for (int k = lo; k <= hi; k++) {\n                if (asc ? a[k] < pivot1 : a[k] > pivot1) {\n                    int t = a[k]; a[k] = a[less]; a[less++] = t;\n                } else if (asc ? a[k] > pivot1 : a[k] < pivot1) {\n                    while (asc ? a[great] > pivot1 : a[great] < pivot1) {\n                        if (great-- == k) break;\n                    }\n                    int t = a[k]; a[k] = a[great]; a[great--] = t;\n                    if (asc ? a[k] < pivot1 : a[k] > pivot1) {\n                        t = a[k]; a[k] = a[less]; a[less++] = t;\n                    }\n                }\n            }\n            stack.push(new int[]{lo, less - 1});\n            stack.push(new int[]{great + 1, hi});\n            continue;\n        }\n        a[e1] = a[less]; a[less++] = pivot1;\n        a[e5] = a[great]; a[great--] = pivot2;\n        for (int k = less; k <= great; k++) {\n            if (asc ? a[k] < pivot1 : a[k] > pivot1) {\n                int t = a[k]; a[k] = a[less]; a[less++] = t;\n            } else if (asc ? a[k] > pivot2 : a[k] < pivot2) {\n                while (asc ? a[great] > pivot2 : a[great] < pivot2) {\n                    if (k >= great--) break;\n                }\n                if (asc ? a[great] < pivot1 : a[great] > pivot1) {\n                    int t = a[k]; a[k] = a[less]; a[less++] = a[great]; a[great--] = t;\n                } else {\n                    int t = a[k]; a[k] = a[great]; a[great--] = t;\n                }\n            }\n        }\n        a[lo] = a[less - 1]; a[less - 1] = pivot1;\n        a[hi] = a[great + 1]; a[great + 1] = pivot2;\n        stack.push(new int[]{lo, less - 2});\n        stack.push(new int[]{great + 2, hi});\n        stack.push(new int[]{less, great});\n    }\n    return a;\n}"
}]