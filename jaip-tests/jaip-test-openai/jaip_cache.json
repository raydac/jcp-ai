[
  {
    "uuid": "e981ea3d-9f1e-482d-a8df-094c449a44d7",
    "instant": "2025-07-19T07:32:58.076162837Z",
    "key": "ULW6+gT8gdk4dUlxR/Vhoj6NqCi5k60A8tuCHugfK5idNDEocav/IGDXfRG96oVLxKnfkYyhCWttwRN1xYlJ5/hhClPtmD3gZziGsG9iB1c\u003d",
    "result": "/**\n * Sorts the given int array using an in-place dual-pivot quicksort algorithm for fastest performance with minimal memory overhead.\n * Returns the same array if it is null, empty, or contains a single element; otherwise, returns a new sorted array in ascending or descending order.\n * The original array is not modified unless it is returned as-is.\n *\n * @param array the int array to sort\n * @param asc true for ascending order, false for descending order\n * @return a new sorted array, or the original if null, empty, or single element\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c 2) return array;\n    int[] a \u003d new int[array.length];\n    System.arraycopy(array, 0, a, 0, array.length);\n    int left \u003d 0, right \u003d a.length - 1;\n    java.util.ArrayDeque\u003cint[]\u003e stack \u003d new java.util.ArrayDeque\u003c\u003e();\n    stack.push(new int[]{left, right});\n    while (!stack.isEmpty()) {\n        int[] bounds \u003d stack.pop();\n        int l \u003d bounds[0], r \u003d bounds[1];\n        if (r - l \u003c 27) {\n            for (int i \u003d l + 1; i \u003c\u003d r; i++) {\n                int v \u003d a[i], j \u003d i - 1;\n                while (j \u003e\u003d l \u0026\u0026 (asc ? a[j] \u003e v : a[j] \u003c v)) {\n                    a[j + 1] \u003d a[j];\n                    j--;\n                }\n                a[j + 1] \u003d v;\n            }\n            continue;\n        }\n        int p1 \u003d a[l], p2 \u003d a[r];\n        if ((asc ? p1 \u003e p2 : p1 \u003c p2)) {\n            int t \u003d a[l]; a[l] \u003d a[r]; a[r] \u003d t;\n            p1 \u003d a[l]; p2 \u003d a[r];\n        }\n        int k \u003d l + 1, g \u003d r - 1, i \u003d k;\n        while (i \u003c\u003d g) {\n            if (asc ? a[i] \u003c p1 : a[i] \u003e p1) {\n                int t \u003d a[i]; a[i] \u003d a[k]; a[k] \u003d t;\n                k++;\n            } else if (asc ? a[i] \u003e p2 : a[i] \u003c p2) {\n                while ((asc ? a[g] \u003e p2 : a[g] \u003c p2) \u0026\u0026 i \u003c g) g--;\n                int t \u003d a[i]; a[i] \u003d a[g]; a[g] \u003d t;\n                g--;\n                if (asc ? a[i] \u003c p1 : a[i] \u003e p1) {\n                    t \u003d a[i]; a[i] \u003d a[k]; a[k] \u003d t;\n                    k++;\n                }\n            }\n            i++;\n        }\n        k--; g++;\n        int t \u003d a[l]; a[l] \u003d a[k]; a[k] \u003d t;\n        t \u003d a[r]; a[r] \u003d a[g]; a[g] \u003d t;\n        stack.push(new int[]{l, k - 1});\n        stack.push(new int[]{k + 1, g - 1});\n        stack.push(new int[]{g + 1, r});\n    }\n    return a;\n}",
    "fileName": "ArraySorter.java",
    "line": 6
  }
]