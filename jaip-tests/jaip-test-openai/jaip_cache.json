[{
  "uuid": "4b897a61-3ce1-48ea-bf5e-f6eca2df10e4",
  "instant": "2025-07-20T07:31:27.356202532Z",
  "key": "xXSDlFqXa/SznNrHu8Id98R9+WfV04tMwVyp6YFTFn64/RyPwUN/kHNvocC/l/GWE4PniTp3tE/d8oUiA0vNO0qgn2hx4mpb7mKMTv1NS4Y=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts the input int array in ascending or descending order with fastest performance and minimal memory overhead.\n * Returns the same array if it is null, empty, or has only a single element; otherwise, returns a new sorted array.\n * The sorting algorithm used is a tuned in-place dual-pivot quicksort, allocating a new array only for the result.\n * No third-party libraries or helper methods are used, everything is implemented inline.\n *\n * @param array the input array to be sorted\n * @param asc true for ascending order, false for descending order\n * @return sorted array as per the order specified by asc\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array == null || array.length < 2) return array;\n    int[] a = array.clone();\n    int l = 0;\n    int r = a.length - 1;\n    java.util.ArrayDeque<int[]> stack = new java.util.ArrayDeque<>();\n    stack.push(new int[]{l, r});\n    java.util.Random rand = new java.util.Random();\n    while (!stack.isEmpty()) {\n        int[] bounds = stack.pop();\n        int left = bounds[0];\n        int right = bounds[1];\n        while (left < right) {\n            int len = right - left + 1;\n            if (len < 32) {\n                for (int i = left + 1; i <= right; i++) {\n                    int key = a[i];\n                    int j = i - 1;\n                    while (j >= left && (asc ? a[j] > key : a[j] < key)) {\n                        a[j + 1] = a[j];\n                        j--;\n                    }\n                    a[j + 1] = key;\n                }\n                break;\n            }\n            int i1 = left + rand.nextInt(len);\n            int i2 = left + rand.nextInt(len);\n            if ((asc ? a[i1] > a[i2] : a[i1] < a[i2])) {\n                int t = a[i1]; a[i1] = a[i2]; a[i2] = t;\n            }\n            int pivot1 = a[i1], pivot2 = a[i2];\n            if ((asc ? pivot1 > pivot2 : pivot1 < pivot2)) {\n                int t = pivot1; pivot1 = pivot2; pivot2 = t;\n            }\n            a[i1] = a[left]; a[left] = pivot1;\n            a[i2] = a[right]; a[right] = pivot2;\n            int less = left + 1, great = right - 1;\n            int k = less;\n            while (k <= great) {\n                if (asc ? a[k] < pivot1 : a[k] > pivot1) {\n                    int t = a[k]; a[k] = a[less]; a[less] = t;\n                    less++;\n                } else if (asc ? a[k] > pivot2 : a[k] < pivot2) {\n                    while (k < great && (asc ? a[great] > pivot2 : a[great] < pivot2)) great--;\n                    int t = a[k]; a[k] = a[great]; a[great] = t;\n                    great--;\n                    if (asc ? a[k] < pivot1 : a[k] > pivot1) {\n                        t = a[k]; a[k] = a[less]; a[less] = t;\n                        less++;\n                    }\n                }\n                k++;\n            }\n            less--;\n            great++;\n            a[left] = a[less]; a[less] = pivot1;\n            a[right] = a[great]; a[great] = pivot2;\n            if (less - left < right - great) {\n                stack.push(new int[]{great + 1, right});\n                stack.push(new int[]{less + 1, great - 1});\n                right = less - 1;\n            } else {\n                stack.push(new int[]{left, less - 1});\n                stack.push(new int[]{less + 1, great - 1});\n                left = great + 1;\n            }\n        }\n    }\n    return a;\n}"
}]