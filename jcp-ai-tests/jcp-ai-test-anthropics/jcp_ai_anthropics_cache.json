[
  {
    "instant": "2025-09-12T22:08:28.857058896Z",
    "key": "xehGrZX+fQd+28e37AfwJRhw7CIEBi/fL2XJeWA4cpmxmBl4ukyBo43njtMbo6MntrwrWwl/1bUGVfGCnwKxbel3jv4jgyyjFG4Gx8FiJVY\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts an integer array using dual-pivot quicksort algorithm with minimal memory overhead.\n * Returns the original array if null, empty, or single element, otherwise returns a new sorted array.\n *\n * @param array the integer array to sort\n * @param asc true for ascending order, false for descending order\n * @return sorted array or original array if no sorting needed\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) {\n        return array;\n    }\n    \n    int[] result \u003d new int[array.length];\n    java.lang.System.arraycopy(array, 0, result, 0, array.length);\n    \n    java.util.Deque\u003cInteger\u003e stack \u003d new java.util.ArrayDeque\u003c\u003e();\n    stack.push(0);\n    stack.push(result.length - 1);\n    \n    while (!stack.isEmpty()) {\n        int high \u003d stack.pop();\n        int low \u003d stack.pop();\n        \n        if (low \u003c high) {\n            if (high - low \u003c 47) {\n                for (int i \u003d low + 1; i \u003c\u003d high; i++) {\n                    int key \u003d result[i];\n                    int j \u003d i - 1;\n                    while (j \u003e\u003d low \u0026\u0026 ((asc \u0026\u0026 result[j] \u003e key) || (!asc \u0026\u0026 result[j] \u003c key))) {\n                        result[j + 1] \u003d result[j];\n                        j--;\n                    }\n                    result[j + 1] \u003d key;\n                }\n            } else {\n                int third \u003d (high - low) / 3;\n                int m1 \u003d low + third;\n                int m2 \u003d high - third;\n                \n                if (result[m1] \u003e result[m2]) {\n                    int temp \u003d result[m1];\n                    result[m1] \u003d result[m2];\n                    result[m2] \u003d temp;\n                }\n                if (result[low] \u003e result[m1]) {\n                    int temp \u003d result[low];\n                    result[low] \u003d result[m1];\n                    result[m1] \u003d temp;\n                }\n                if (result[m2] \u003e result[high]) {\n                    int temp \u003d result[m2];\n                    result[m2] \u003d result[high];\n                    result[high] \u003d temp;\n                }\n                if (result[m1] \u003e result[m2]) {\n                    int temp \u003d result[m1];\n                    result[m1] \u003d result[m2];\n                    result[m2] \u003d temp;\n                }\n                if (result[low] \u003e result[m1]) {\n                    int temp \u003d result[low];\n                    result[low] \u003d result[m1];\n                    result[m1] \u003d temp;\n                }\n                if (result[m2] \u003e result[high]) {\n                    int temp \u003d result[m2];\n                    result[m2] \u003d result[high];\n                    result[high] \u003d temp;\n                }\n                \n                int pivot1 \u003d result[m1];\n                int pivot2 \u003d result[m2];\n                \n                result[m1] \u003d result[low];\n                result[m2] \u003d result[high];\n                \n                int less \u003d low + 1;\n                int great \u003d high - 1;\n                \n                for (int k \u003d less; k \u003c\u003d great; k++) {\n                    if (asc ? result[k] \u003c pivot1 : result[k] \u003e pivot1) {\n                        int temp \u003d result[k];\n                        result[k] \u003d result[less];\n                        result[less] \u003d temp;\n                        less++;\n                    } else if (asc ? result[k] \u003e pivot2 : result[k] \u003c pivot2) {\n                        while (k \u003c great \u0026\u0026 (asc ? result[great] \u003e pivot2 : result[great] \u003c pivot2)) {\n                            great--;\n                        }\n                        int temp \u003d result[k];\n                        result[k] \u003d result[great];\n                        result[great] \u003d temp;\n                        great--;\n                        if (asc ? result[k] \u003c pivot1 : result[k] \u003e pivot1) {\n                            temp \u003d result[k];\n                            result[k] \u003d result[less];\n                            result[less] \u003d temp;\n                            less++;\n                        }\n                    }\n                }\n                \n                result[low] \u003d result[less - 1];\n                result[less - 1] \u003d pivot1;\n                result[high] \u003d result[great + 1];\n                result[great + 1] \u003d pivot2;\n                \n                stack.push(low);\n                stack.push(less - 2);\n                stack.push(less);\n                stack.push(great);\n                stack.push(great + 2);\n                stack.push(high);\n            }\n        }\n    }\n    \n    return result;\n}",
    "sinceUse": 0
  }
]