[
  {
    "uuid": "494b27e9-4e1e-4ef9-9ec2-d51dc3762ae5",
    "instant": "2025-08-02T19:17:31.514583626Z",
    "key": "ZNuCEXEnYH1jX6kE5r4mY2nsNZWL1ZUB8pYcHxdmee8FLbLI2aX9Kg7WUPvOHwvYF4p5F0SmLNor5wxLpMgCpSp/tgjaohmWBO8HCCC0IWU=",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts the given array using an optimized quicksort implementation with minimal memory overhead.\n * The sorting order is determined by the asc parameter (ascending if true, descending if false).\n * Returns the original array if it is null, empty, or contains a single element; otherwise returns\n * a new sorted array. This implementation uses median-of-three pivot selection and insertion sort\n * for small subarrays to optimize performance.\n *\n * @param array the array to be sorted\n * @param asc   flag indicating sorting order (true for ascending, false for descending)\n * @return the sorted array (or original array if no sorting needed)\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n    int[] result = java.util.Arrays.copyOf(array, array.length);\n    quickSort(result, 0, result.length - 1, asc);\n    return result;\n}\n\nprivate static void quickSort(int[] arr, int low, int high, boolean asc) {\n    while (low < high) {\n        if (high - low < 16) {\n            insertionSort(arr, low, high, asc);\n            break;\n        }\n        int pivot = partition(arr, low, high, asc);\n        if (pivot - low < high - pivot) {\n            quickSort(arr, low, pivot - 1, asc);\n            low = pivot + 1;\n        } else {\n            quickSort(arr, pivot + 1, high, asc);\n            high = pivot - 1;\n        }\n    }\n}\n\nprivate static int partition(int[] arr, int low, int high, boolean asc) {\n    int mid = low + (high - low) / 2;\n    int pivotValue = medianOfThree(arr, low, mid, high, asc);\n    int i = low - 1;\n    int j = high + 1;\n    while (true) {\n        do {\n            i++;\n        } while (asc ? arr[i] < pivotValue : arr[i] > pivotValue);\n        do {\n            j--;\n        } while (asc ? arr[j] > pivotValue : arr[j] < pivotValue);\n        if (i >= j) {\n            return j;\n        }\n        swap(arr, i, j);\n    }\n}\n\nprivate static int medianOfThree(int[] arr, int a, int b, int c, boolean asc) {\n    if ((asc && arr[a] > arr[b]) || (!asc && arr[a] < arr[b])) {\n        swap(arr, a, b);\n    }\n    if ((asc && arr[a] > arr[c]) || (!asc && arr[a] < arr[c])) {\n        swap(arr, a, c);\n    }\n    if ((asc && arr[b] > arr[c]) || (!asc && arr[b] < arr[c])) {\n        swap(arr, b, c);\n    }\n    return arr[b];\n}\n\nprivate static void insertionSort(int[] arr, int low, int high, boolean asc) {\n    for (int i = low + 1; i <= high; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= low && ((asc && arr[j] > key) || (!asc && arr[j] < key))) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nprivate static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}",
    "sinceUse": 0
  }
]