[
  {
    "instant": "2025-09-12T22:10:15.543450492Z",
    "key": "i+KFhPiLVJplSwWJBf/Tmn2GCbmvIUF9WhZcWHh9tJVkjyUOkJCGfmQ+/IIVo+AEgmnOypHjVboLgfMsCmO++BEi3qAlKfgGUe9qd8FP4bQ\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts the given array using an optimized quicksort algorithm with minimal memory overhead.\n * The algorithm uses a median-of-three pivot selection and iterative stack-based partitioning\n * to avoid recursion and reduce stack depth. For small subarrays, it switches to insertion sort\n * for better performance. The sort order is determined by the asc flag.\n *\n * @param array the array to be sorted, may be null\n * @param asc   if true, sorts in ascending order; otherwise descending\n * @return the sorted array (same reference if input is null, empty, or single element)\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) {\n        return array;\n    }\n    final int n \u003d array.length;\n    int[] stack \u003d new int[64];\n    int top \u003d -1;\n    stack[++top] \u003d 0;\n    stack[++top] \u003d n - 1;\n    while (top \u003e\u003d 0) {\n        int high \u003d stack[top--];\n        int low \u003d stack[top--];\n        if (high - low \u003c 16) {\n            for (int i \u003d low + 1; i \u003c\u003d high; i++) {\n                int key \u003d array[i];\n                int j \u003d i - 1;\n                while (j \u003e\u003d low \u0026\u0026 (asc ? array[j] \u003e key : array[j] \u003c key)) {\n                    array[j + 1] \u003d array[j];\n                    j--;\n                }\n                array[j + 1] \u003d key;\n            }\n            continue;\n        }\n        int mid \u003d low + (high - low) / 2;\n        if (asc ? array[mid] \u003c array[low] : array[mid] \u003e array[low]) {\n            int temp \u003d array[low];\n            array[low] \u003d array[mid];\n            array[mid] \u003d temp;\n        }\n        if (asc ? array[high] \u003c array[low] : array[high] \u003e array[low]) {\n            int temp \u003d array[low];\n            array[low] \u003d array[high];\n            array[high] \u003d temp;\n        }\n        if (asc ? array[mid] \u003c array[high] : array[mid] \u003e array[high]) {\n            int temp \u003d array[mid];\n            array[mid] \u003d array[high];\n            array[high] \u003d temp;\n        }\n        int pivot \u003d array[high];\n        int i \u003d low - 1;\n        for (int j \u003d low; j \u003c high; j++) {\n            if (asc ? array[j] \u003c\u003d pivot : array[j] \u003e\u003d pivot) {\n                i++;\n                int temp \u003d array[i];\n                array[i] \u003d array[j];\n                array[j] \u003d temp;\n            }\n        }\n        int temp \u003d array[i + 1];\n        array[i + 1] \u003d array[high];\n        array[high] \u003d temp;\n        int p \u003d i + 1;\n        if (p - 1 \u003e low) {\n            stack[++top] \u003d low;\n            stack[++top] \u003d p - 1;\n        }\n        if (p + 1 \u003c high) {\n            stack[++top] \u003d p + 1;\n            stack[++top] \u003d high;\n        }\n    }\n    return array;\n}",
    "sinceUse": 0
  }
]