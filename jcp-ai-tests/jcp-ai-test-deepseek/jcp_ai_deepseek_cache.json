[
  {
    "instant": "2025-10-05T14:53:03.090228048Z",
    "key": "i+KFhPiLVJplSwWJBf/Tmn2GCbmvIUF9WhZcWHh9tJVkjyUOkJCGfmQ+/IIVo+AEgmnOypHjVboLgfMsCmO++BEi3qAlKfgGUe9qd8FP4bQ\u003d",
    "fileName": "ArraySorter.java",
    "line": 24,
    "result": "/**\n * Sorts the given array using an optimized quicksort algorithm with minimal memory overhead.\n * This implementation uses iterative quicksort with a manual stack and insertion sort for small subarrays.\n * \n * @param array the array to be sorted, may be null or empty\n * @param asc if true, sorts in ascending order; if false, sorts in descending order\n * @return the same array if null, empty, or single element; otherwise a new sorted array\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) {\n        return array;\n    }\n    \n    int[] result \u003d array.clone();\n    int[] stack \u003d new int[64];\n    int top \u003d -1;\n    stack[++top] \u003d 0;\n    stack[++top] \u003d result.length - 1;\n    \n    while (top \u003e\u003d 0) {\n        int high \u003d stack[top--];\n        int low \u003d stack[top--];\n        \n        if (high - low \u003c 16) {\n            for (int i \u003d low + 1; i \u003c\u003d high; i++) {\n                int key \u003d result[i];\n                int j \u003d i - 1;\n                while (j \u003e\u003d low \u0026\u0026 (asc ? result[j] \u003e key : result[j] \u003c key)) {\n                    result[j + 1] \u003d result[j];\n                    j--;\n                }\n                result[j + 1] \u003d key;\n            }\n            continue;\n        }\n        \n        int pivot \u003d result[high];\n        int i \u003d low - 1;\n        for (int j \u003d low; j \u003c high; j++) {\n            if (asc ? result[j] \u003c\u003d pivot : result[j] \u003e\u003d pivot) {\n                i++;\n                int temp \u003d result[i];\n                result[i] \u003d result[j];\n                result[j] \u003d temp;\n            }\n        }\n        int temp \u003d result[i + 1];\n        result[i + 1] \u003d result[high];\n        result[high] \u003d temp;\n        int p \u003d i + 1;\n        \n        if (p - 1 \u003e low) {\n            stack[++top] \u003d low;\n            stack[++top] \u003d p - 1;\n        }\n        if (p + 1 \u003c high) {\n            stack[++top] \u003d p + 1;\n            stack[++top] \u003d high;\n        }\n    }\n    \n    return result;\n}",
    "sinceUse": 0
  }
]