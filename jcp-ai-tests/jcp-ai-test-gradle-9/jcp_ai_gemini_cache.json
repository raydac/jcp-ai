[
  {
    "uuid": "a129ccbc-4eb0-4e31-80b8-2c4b30d74fac",
    "instant": "2025-07-28T07:06:47.942203025Z",
    "key": "m/1k5KeMYeqdfmd0niPNDwjYAzJZHPoGwqLd7RaRzqzUr2MygljHJpOdgGJ9rlTiIUNWqy3tN+OAyQWvDC1rycRmqtGN8HL1IkzsuTQZhpE=",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts an array of integers using an iterative Quicksort algorithm.\n * This method prioritizes speed and aims for minimal memory overhead while adhering\n * to strict constraints: no external libraries, no helper methods, and a compact\n * single-method implementation.\n *\n * The algorithm used is an iterative Quicksort with Lomuto partition scheme.\n * To ensure O(log N) stack space complexity, it always processes the smaller\n * partition first by pushing the larger partition onto the stack before the smaller one.\n *\n * @param array The array to be sorted.\n * @param asc   If true, sort in ascending order; otherwise, sort in descending order.\n * @return The sorted array. Returns the original array if it is null, empty, or contains a single value.\n *         Otherwise, returns a new array with the sorted values.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int[] result = java.util.Arrays.copyOf(array, array.length);\n\n    // Iterative Quicksort implementation using an array as a stack.\n    // The maximum stack depth for Quicksort is O(log N) when the smaller\n    // partition is always processed first. For an int array (max length 2^31-1),\n    // log2(2^31) is approximately 31. Each stack entry stores two integers (low, high).\n    // Thus, a stack size of 2 * 31 = 62 is theoretically sufficient.\n    // A size of 128 (a power of 2) provides a safe margin for practical purposes.\n    int[] stack = new int[128];\n    int top = -1;\n\n    // Push the initial range (entire array) onto the stack\n    stack[++top] = 0;\n    stack[++top] = result.length - 1;\n\n    while (top >= 0) {\n        int high = stack[top--];\n        int low = stack[top--];\n\n        if (low < high) {\n            // Lomuto partition scheme:\n            // Choose the last element as the pivot.\n            int pivot = result[high];\n            int i = low - 1; // Index of smaller element\n\n            for (int j = low; j < high; j++) {\n                if (asc) {\n                    if (result[j] <= pivot) {\n                        i++;\n                        int temp = result[i];\n                        result[i] = result[j];\n                        result[j] = temp;\n                    }\n                } else { // Descending order\n                    if (result[j] >= pivot) {\n                        i++;\n                        int temp = result[i];\n                        result[i] = result[j];\n                        result[j] = temp;\n                    }\n                }\n            }\n\n            // Place the pivot in its correct sorted position\n            int temp = result[i + 1];\n            result[i + 1] = result[high];\n            result[high] = temp;\n            int partitionIndex = i + 1;\n\n            // Push sub-arrays onto the stack.\n            // To maintain O(log N) stack depth, always push the larger partition first.\n            // This ensures the smaller partition is processed in the next iteration,\n            // limiting the maximum stack depth.\n            if (partitionIndex - 1 - low > high - (partitionIndex + 1)) { // Left partition is larger\n                stack[++top] = low;\n                stack[++top] = partitionIndex - 1;\n                stack[++top] = partitionIndex + 1;\n                stack[++top] = high;\n            } else { // Right partition is larger or equal, or left is empty\n                stack[++top] = partitionIndex + 1;\n                stack[++top] = high;\n                stack[++top] = low;\n                stack[++top] = partitionIndex - 1;\n            }\n        }\n    }\n    return result;\n}",
    "sinceUse": 0
  }
] "sinceUse": 0
  }
]