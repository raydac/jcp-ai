[
  {
    "uuid": "0591b65d-9a25-48b0-8f57-1a7a1ce3f60d",
    "instant": "2025-08-01T22:24:56.277794207Z",
    "key": "m/1k5KeMYeqdfmd0niPNDwjYAzJZHPoGwqLd7RaRzqzUr2MygljHJpOdgGJ9rlTiIUNWqy3tN+OAyQWvDC1rycRmqtGN8HL1IkzsuTQZhpE=",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts an array of integers using the HeapSort algorithm.\n * This method prioritizes speed and minimal memory overhead while adhering to strict constraints\n * of being a single method without any external helper functions or libraries for the sorting logic.\n *\n * @param array The array of integers to be sorted. If null, empty, or contains a single element,\n *              the original array instance is returned.\n * @param asc   A boolean flag indicating the sorting order. If true, the array is sorted in\n *              ascending order; otherwise, it is sorted in descending order.\n * @return A new array instance containing the sorted values if the input array has more than one element.\n *         Returns the original array instance if it is null, empty, or single-valued.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int[] result = new int[array.length];\n    for (int k = 0; k < array.length; k++) {\n        result[k] = array[k];\n    }\n\n    int n = result.length;\n\n    // Phase 1: Build heap (max-heap for ascending sort, min-heap for descending sort)\n    // Iterate from the last non-leaf node up to the root (index (n/2) - 1 down to 0)\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        // Inlined heapify logic for the subtree rooted at 'i'\n        int currentRootIndex = i;\n        int currentHeapSize = n; // The full array is the heap initially\n\n        while (true) {\n            int targetIndex = currentRootIndex;\n            int leftChildIndex = 2 * currentRootIndex + 1;\n            int rightChildIndex = 2 * currentRootIndex + 2;\n\n            if (asc) { // For ascending order, build a max-heap\n                if (leftChildIndex < currentHeapSize && result[leftChildIndex] > result[targetIndex]) {\n                    targetIndex = leftChildIndex;\n                }\n                if (rightChildIndex < currentHeapSize && result[rightChildIndex] > result[targetIndex]) {\n                    targetIndex = rightChildIndex;\n                }\n            } else { // For descending order, build a min-heap\n                if (leftChildIndex < currentHeapSize && result[leftChildIndex] < result[targetIndex]) {\n                    targetIndex = leftChildIndex;\n                }\n                if (rightChildIndex < currentHeapSize && result[rightChildIndex] < result[targetIndex]) {\n                    targetIndex = rightChildIndex;\n                }\n            }\n\n            if (targetIndex != currentRootIndex) {\n                // Swap result[currentRootIndex] and result[targetIndex]\n                int temp = result[currentRootIndex];\n                result[currentRootIndex] = result[targetIndex];\n                result[targetIndex] = temp;\n                currentRootIndex = targetIndex; // Move down the heap to continue heapifying\n            } else {\n                break; // Heap property satisfied for this subtree\n            }\n        }\n    }\n\n    // Phase 2: Extract elements from heap one by one\n    // The largest/smallest element is at result[0], swap it with the last element of the current heap\n    // and then reduce the heap size and heapify the root.\n    for (int i = n - 1; i > 0; i--) {\n        // Swap result[0] (root) with result[i] (last element of current heap)\n        int temp = result[0];\n        result[0] = result[i];\n        result[i] = temp;\n\n        // Inlined heapify logic for the new root (index 0) of the reduced heap\n        int currentRootIndex = 0;\n        int currentHeapSize = i; // Heap size decreases by 1 in each iteration\n\n        while (true) {\n            int targetIndex = currentRootIndex;\n            int leftChildIndex = 2 * currentRootIndex + 1;\n            int rightChildIndex = 2 * currentRootIndex + 2;\n\n            if (asc) { // For ascending order, maintain a max-heap\n                if (leftChildIndex < currentHeapSize && result[leftChildIndex] > result[targetIndex]) {\n                    targetIndex = leftChildIndex;\n                }\n                if (rightChildIndex < currentHeapSize && result[rightChildIndex] > result[targetIndex]) {\n                    targetIndex = rightChildIndex;\n                }\n            } else { // For descending order, maintain a min-heap\n                if (leftChildIndex < currentHeapSize && result[leftChildIndex] < result[targetIndex]) {\n                    targetIndex = leftChildIndex;\n                }\n                if (rightChildIndex < currentHeapSize && result[rightChildIndex] < result[targetIndex]) {\n                    targetIndex = rightChildIndex;\n                }\n            }\n\n            if (targetIndex != currentRootIndex) {\n                // Swap result[currentRootIndex] and result[targetIndex]\n                int temp2 = result[currentRootIndex];\n                result[currentRootIndex] = result[targetIndex];\n                result[targetIndex] = temp2;\n                currentRootIndex = targetIndex; // Move down the heap to continue heapifying\n            } else {\n                break; // Heap property satisfied for this subtree\n            }\n        }\n    }\n\n    return result;\n}",
    "sinceUse": 0
  }
]