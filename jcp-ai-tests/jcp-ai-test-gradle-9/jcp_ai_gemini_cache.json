[
  {
    "uuid": "3d526052-0f51-41c5-b815-2fcaa8ba7498",
    "instant": "2025-08-09T08:53:20.564721015Z",
    "key": "kCeQN6mLC/K4LPKNoh4QmIU1tNcH3o6NdysdIDNsL5U/TR55YTRMIjNI2NVGpaN0S0/rdZa4yk2ldIZsQBZFasFkxJ1DUtzGR2NVEq9U238=",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts an array of integers using the HeapSort algorithm.\n * This method prioritizes speed and has minimal memory overhead (O(1) auxiliary space).\n * It does not use any external libraries or helper methods, implementing the sort entirely within itself.\n *\n * @param array The array to be sorted.\n * @param asc   If true, the array will be sorted in ascending order; otherwise, in descending order.\n * @return The same incoming array if it is null, empty, or a single-value array.\n *         Otherwise, returns a new array with the sorted values.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int n = array.length;\n    int[] result = new int[n];\n    java.lang.System.arraycopy(array, 0, result, 0, n);\n\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        int currentRoot = i;\n        int heapSize = n;\n        while (true) {\n            int largest = currentRoot;\n            int leftChild = 2 * currentRoot + 1;\n            int rightChild = 2 * currentRoot + 2;\n\n            if (leftChild < heapSize && result[leftChild] > result[largest]) {\n                largest = leftChild;\n            }\n            if (rightChild < heapSize && result[rightChild] > result[largest]) {\n                largest = rightChild;\n            }\n\n            if (largest != currentRoot) {\n                int temp = result[currentRoot];\n                result[currentRoot] = result[largest];\n                result[largest] = temp;\n                currentRoot = largest;\n            } else {\n                break;\n            }\n        }\n    }\n\n    for (int i = n - 1; i > 0; i--) {\n        int temp = result[0];\n        result[0] = result[i];\n        result[i] = temp;\n\n        int currentRoot = 0;\n        int heapSize = i;\n        while (true) {\n            int largest = currentRoot;\n            int leftChild = 2 * currentRoot + 1;\n            int rightChild = 2 * currentRoot + 2;\n\n            if (leftChild < heapSize && result[leftChild] > result[largest]) {\n                largest = leftChild;\n            }\n            if (rightChild < heapSize && result[rightChild] > result[largest]) {\n                largest = rightChild;\n            }\n\n            if (largest != currentRoot) {\n                temp = result[currentRoot];\n                result[currentRoot] = result[largest];\n                result[largest] = temp;\n                currentRoot = largest;\n            } else {\n                break;\n            }\n        }\n    }\n\n    if (!asc) {\n        for (int i = 0; i < n / 2; i++) {\n            int temp = result[i];\n            result[i] = result[n - 1 - i];\n            result[n - 1 - i] = temp;\n        }\n    }\n\n    return result;\n}",
    "sinceUse": 0
  }
]