[
  {
    "uuid": "1eabba4d-8eaa-4668-bee0-ef9f4060314c",
    "instant": "2025-08-02T19:18:57.866306455Z",
    "key": "kCeQN6mLC/K4LPKNoh4QmIU1tNcH3o6NdysdIDNsL5U/TR55YTRMIjNI2NVGpaN0S0/rdZa4yk2ldIZsQBZFasFkxJ1DUtzGR2NVEq9U238=",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts an array of integers using an in-place HeapSort algorithm.\n * This method prioritizes speed and minimal memory overhead,\n * adhering to strict constraints of not using external helper methods\n * or utility classes, and containing all logic within a single method.\n *\n * @param array The array of integers to be sorted.\n * @param asc   If true, sort in ascending order; otherwise, sort in descending order.\n * @return A new array with sorted values, or the original array if it is null, empty, or contains a single value.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    final int n = array.length;\n    int[] result = new int[n];\n    for (int i = 0; i < n; i++) {\n        result[i] = array[i];\n    }\n\n    // Phase 1: Build a max-heap from the array (in-place)\n    // Iterate from the last non-leaf node up to the root (index 0)\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        int k = i; // Current node index to sift down\n        while (true) {\n            int child = 2 * k + 1; // Left child index\n            if (child >= n) { // No children or left child out of bounds\n                break;\n            }\n\n            // Find the larger child (if right child exists and is larger)\n            if (child + 1 < n && result[child] < result[child + 1]) {\n                child++; // Right child is larger\n            }\n\n            // If current node is smaller than its largest child, swap them\n            if (result[k] < result[child]) {\n                int temp = result[k];\n                result[k] = result[child];\n                result[child] = temp;\n                k = child; // Move down to the child and continue sifting\n            } else {\n                break; // Node is in correct position, heap property maintained\n            }\n        }\n    }\n\n    // Phase 2: Extract elements from the heap one by one (in-place sort)\n    // The largest element (root) is swapped with the last element of the current heap,\n    // and the heap size is reduced. Then, the new root is sifted down.\n    for (int i = n - 1; i > 0; i--) {\n        // Swap root (largest element) with the current last element of the heap\n        int temp = result[0];\n        result[0] = result[i];\n        result[i] = temp;\n\n        // Sift down the new root to maintain the heap property for the reduced heap\n        int k = 0; // Current node index (always starting from root)\n        int heapSize = i; // The effective size of the heap decreases by 1 in each iteration\n        while (true) {\n            int child = 2 * k + 1; // Left child index\n            if (child >= heapSize) { // No children or left child out of bounds for current heap size\n                break;\n            }\n\n            // Find the larger child within the current heap size\n            if (child + 1 < heapSize && result[child] < result[child + 1]) {\n                child++; // Right child is larger\n            }\n\n            // If current node is smaller than its largest child, swap them\n            if (result[k] < result[child]) {\n                int temp2 = result[k];\n                result[k] = result[child];\n                result[child] = temp2;\n                k = child; // Move down to the child and continue sifting\n            } else {\n                break; // Node is in correct position, heap property maintained\n            }\n        }\n    }\n\n    // Phase 3: Handle descending order if required\n    // If ascending order is not desired, reverse the already sorted array\n    if (!asc) {\n        for (int i = 0; i < n / 2; i++) {\n            int temp = result[i];\n            result[i] = result[n - 1 - i];\n            result[n - 1 - i] = temp;\n        }\n    }\n\n    return result;\n}",
    "sinceUse": 0
  }
]