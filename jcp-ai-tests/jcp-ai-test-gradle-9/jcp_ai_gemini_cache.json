[
  {
    "uuid": "94665e05-2a2f-462a-bcb2-bc6b43075b49",
    "instant": "2025-08-01T22:56:18.735992400Z",
    "key": "m/1k5KeMYeqdfmd0niPNDwjYAzJZHPoGwqLd7RaRzqzUr2MygljHJpOdgGJ9rlTiIUNWqy3tN+OAyQWvDC1rycRmqtGN8HL1IkzsuTQZhpE=",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts an array of integers using the Heapsort algorithm.\n * This method prioritizes speed and has minimal memory overhead (O(1) auxiliary space for sorting,\n * plus O(N) for the new result array).\n * All implementation details, including the heapify logic, are contained within this single method\n * without relying on external libraries, helper methods, or utility classes.\n *\n * @param array The array of integers to be sorted.\n * @param asc   If true, the array will be sorted in ascending order; otherwise, in descending order.\n * @return The same incoming array if it is null, empty, or a single-value array.\n *         Otherwise, returns a new array containing the sorted values.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int[] result = new int[array.length];\n    java.lang.System.arraycopy(array, 0, result, 0, array.length);\n\n    int n = result.length;\n\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        int rootIndex = i;\n        int currentHeapSize = n;\n\n        while (true) {\n            int targetIndex = rootIndex;\n            int leftChild = 2 * rootIndex + 1;\n            int rightChild = 2 * rootIndex + 2;\n\n            if (leftChild < currentHeapSize) {\n                if (asc) {\n                    if (result[leftChild] > result[targetIndex]) {\n                        targetIndex = leftChild;\n                    }\n                } else {\n                    if (result[leftChild] < result[targetIndex]) {\n                        targetIndex = leftChild;\n                    }\n                }\n            }\n\n            if (rightChild < currentHeapSize) {\n                if (asc) {\n                    if (result[rightChild] > result[targetIndex]) {\n                        targetIndex = rightChild;\n                    }\n                } else {\n                    if (result[rightChild] < result[targetIndex]) {\n                        targetIndex = rightChild;\n                    }\n                }\n            }\n\n            if (targetIndex != rootIndex) {\n                int swap = result[rootIndex];\n                result[rootIndex] = result[targetIndex];\n                result[targetIndex] = swap;\n                rootIndex = targetIndex;\n            } else {\n                break;\n            }\n        }\n    }\n\n    for (int i = n - 1; i > 0; i--) {\n        int temp = result[0];\n        result[0] = result[i];\n        result[i] = temp;\n\n        int rootIndex = 0;\n        int currentHeapSize = i;\n\n        while (true) {\n            int targetIndex = rootIndex;\n            int leftChild = 2 * rootIndex + 1;\n            int rightChild = 2 * rootIndex + 2;\n\n            if (leftChild < currentHeapSize) {\n                if (asc) {\n                    if (result[leftChild] > result[targetIndex]) {\n                        targetIndex = leftChild;\n                    }\n                } else {\n                    if (result[leftChild] < result[targetIndex]) {\n                        targetIndex = leftChild;\n                    }\n                }\n            }\n\n            if (rightChild < currentHeapSize) {\n                if (asc) {\n                    if (result[rightChild] > result[targetIndex]) {\n                        targetIndex = rightChild;\n                    }\n                } else {\n                    if (result[rightChild] < result[targetIndex]) {\n                        targetIndex = rightChild;\n                    }\n                }\n            }\n\n            if (targetIndex != rootIndex) {\n                int swap = result[rootIndex];\n                result[rootIndex] = result[targetIndex];\n                result[targetIndex] = swap;\n                rootIndex = targetIndex;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return result;\n}",
    "sinceUse": 0
  }
]