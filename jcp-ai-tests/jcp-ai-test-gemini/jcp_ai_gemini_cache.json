[{
  "uuid": "7084a873-2093-48d0-be67-5d4119c93aa4",
  "instant": "2025-07-24T06:38:23.802026102Z",
  "key": "tBeMqvVnM5QcBjUZ/+TxUZ6Fl+/Mojpm7a+Nw6rseeIua7lxs8DAJtOsc4M7um0lgBrmDWVfckUOuhfeVo2rLvc7R4KnHfmNwLY/CnFovNs=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts an array of integers using an optimized Heapsort algorithm.\n * This method prioritizes speed and minimal memory overhead,\n * implementing the sorting logic entirely within itself without\n * external libraries, helper methods, or recursion.\n *\n * @param array The array to be sorted.\n * @param asc   If true, sorts in ascending order; otherwise, sorts in descending order.\n * @return The same incoming array if it is null, empty, or a single-value array.\n *         Otherwise, returns a new array with the sorted values.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int n = array.length;\n    int[] result = new int[n];\n    for (int i = 0; i < n; i++) {\n        result[i] = array[i];\n    }\n\n    // Build max-heap (heapify phase)\n    // Start from the last non-leaf node and go up to the root\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        int rootIndex = i;\n        int rootValue = result[rootIndex]; // Value to be sifted down\n        int childIndex;\n\n        // Sift down the rootValue to maintain heap property\n        while ((childIndex = 2 * rootIndex + 1) < n) { // Left child exists\n            // Check if right child exists and is greater than left child\n            if (childIndex + 1 < n && result[childIndex] < result[childIndex + 1]) {\n                childIndex++; // Use the right child as it's larger\n            }\n            // If the rootValue is less than the largest child\n            if (rootValue < result[childIndex]) {\n                result[rootIndex] = result[childIndex]; // Move child up\n                rootIndex = childIndex; // Move down to the child's position\n            } else {\n                break; // Heap property satisfied, rootValue is in correct position\n            }\n        }\n        result[rootIndex] = rootValue; // Place the original rootValue in its final position\n    }\n\n    // Extract elements from heap one by one (sort phase)\n    // Loop from the end of the array down to the first element\n    for (int i = n - 1; i > 0; i--) {\n        // Move current root (largest element) to the end of the unsorted part\n        int temp = result[0];\n        result[0] = result[i];\n        result[i] = temp;\n\n        // Sift down the new root to maintain heap property on the reduced heap\n        int rootIndex = 0;\n        int rootValue = result[rootIndex]; // New root value to be sifted down\n        int currentHeapSize = i; // The heap size decreases by 1 in each iteration\n        int childIndex;\n\n        while ((childIndex = 2 * rootIndex + 1) < currentHeapSize) { // Left child exists within current heap size\n            // Check if right child exists within current heap size and is greater than left child\n            if (childIndex + 1 < currentHeapSize && result[childIndex] < result[childIndex + 1]) {\n                childIndex++; // Use the right child as it's larger\n            }\n            // If the rootValue is less than the largest child\n            if (rootValue < result[childIndex]) {\n                result[rootIndex] = result[childIndex]; // Move child up\n                rootIndex = childIndex; // Move down to the child's position\n            } else {\n                break; // Heap property satisfied, rootValue is in correct position\n            }\n        }\n        result[rootIndex] = rootValue; // Place the original rootValue in its final position\n    }\n\n    // Handle descending order if requested\n    if (!asc) {\n        for (int i = 0; i < n / 2; i++) {\n            int temp = result[i];\n            result[i] = result[n - 1 - i];\n            result[n - 1 - i] = temp;\n        }\n    }\n\n    return result;\n}"
}]