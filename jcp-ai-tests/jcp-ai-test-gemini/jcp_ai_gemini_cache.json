[
  {
    "instant": "2025-08-14T05:21:49.341077896Z",
    "key": "kCeQN6mLC/K4LPKNoh4QmIU1tNcH3o6NdysdIDNsL5U/TR55YTRMIjNI2NVGpaN0S0/rdZa4yk2ldIZsQBZFasFkxJ1DUtzGR2NVEq9U238\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts an array of integers using an iterative Quicksort algorithm.\n * This method prioritizes speed and minimal memory overhead.\n * It does not use any external libraries or helper methods,\n * implementing the sorting logic entirely within this single method.\n *\n * @param array The array to be sorted.\n * @param asc   If true, sorts in ascending order; otherwise, sorts in descending order.\n * @return The same incoming array if it is null, empty, or a single-value array.\n *         Otherwise, returns a new array with the sorted values.\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) {\n        return array;\n    }\n\n    int[] result \u003d java.util.Arrays.copyOf(array, array.length);\n\n    int N \u003d result.length;\n\n    int[] stack \u003d new int[128];\n    int stackPointer \u003d -1;\n\n    stack[++stackPointer] \u003d 0;\n    stack[++stackPointer] \u003d N - 1;\n\n    while (stackPointer \u003e\u003d 0) {\n        int high \u003d stack[stackPointer--];\n        int low \u003d stack[stackPointer--];\n\n        if (low \u003c high) {\n            int pivot \u003d result[high];\n            int i \u003d low - 1;\n\n            for (int j \u003d low; j \u003c high; j++) {\n                boolean condition;\n                if (asc) {\n                    condition \u003d result[j] \u003c\u003d pivot;\n                } else {\n                    condition \u003d result[j] \u003e\u003d pivot;\n                }\n\n                if (condition) {\n                    i++;\n                    int temp \u003d result[i];\n                    result[i] \u003d result[j];\n                    result[j] \u003d temp;\n                }\n            }\n\n            int temp \u003d result[i + 1];\n            result[i + 1] \u003d result[high];\n            result[high] \u003d temp;\n\n            int pivotIndex \u003d i + 1;\n\n            boolean pushLeft \u003d (pivotIndex - 1) \u003e low;\n            boolean pushRight \u003d high \u003e (pivotIndex + 1);\n\n            if (pushLeft \u0026\u0026 pushRight) {\n                int leftSize \u003d (pivotIndex - 1) - low;\n                int rightSize \u003d high - (pivotIndex + 1);\n\n                if (leftSize \u003e rightSize) {\n                    stack[++stackPointer] \u003d low;\n                    stack[++stackPointer] \u003d pivotIndex - 1;\n                    stack[++stackPointer] \u003d pivotIndex + 1;\n                    stack[++stackPointer] \u003d high;\n                } else {\n                    stack[++stackPointer] \u003d pivotIndex + 1;\n                    stack[++stackPointer] \u003d high;\n                    stack[++stackPointer] \u003d low;\n                    stack[++stackPointer] \u003d pivotIndex - 1;\n                }\n            } else if (pushLeft) {\n                stack[++stackPointer] \u003d low;\n                stack[++stackPointer] \u003d pivotIndex - 1;\n            } else if (pushRight) {\n                stack[++stackPointer] \u003d pivotIndex + 1;\n                stack[++stackPointer] \u003d high;\n            }\n        }\n    }\n\n    return result;\n}",
    "sinceUse": 0
  }
]