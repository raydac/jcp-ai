[{
  "uuid": "4f9c61bd-c5d8-4101-90ed-7eb7730f625e",
  "instant": "2025-08-09T08:45:02.571053343Z",
  "key": "kCeQN6mLC/K4LPKNoh4QmIU1tNcH3o6NdysdIDNsL5U/TR55YTRMIjNI2NVGpaN0S0/rdZa4yk2ldIZsQBZFasFkxJ1DUtzGR2NVEq9U238=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts an array of integers using the HeapSort algorithm.\n * This method prioritizes speed and has minimal memory overhead (beyond the copy of the input array).\n * It handles null, empty, or single-element arrays by returning the original array instance.\n * For arrays with more than one element, it returns a new array containing the sorted values.\n * The sorting order (ascending or descending) is determined by the {@code asc} flag.\n *\n * @param array The array of integers to be sorted.\n * @param asc   If true, the array will be sorted in ascending order; otherwise, in descending order.\n * @return The original array if it's null, empty, or contains a single element;\n *         otherwise, a new array with the sorted values.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int[] result = new int[array.length];\n    java.lang.System.arraycopy(array, 0, result, 0, array.length);\n\n    int n = result.length;\n\n    // Build heap (rearrange array)\n    // Iterate from the last non-leaf node up to the root, performing sift-down for each\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        int rootIndex = i;\n        int currentHeapSize = n;\n\n        // Inlined siftDown logic for building the heap\n        while (true) {\n            int leftChildIndex = 2 * rootIndex + 1;\n            int rightChildIndex = 2 * rootIndex + 2;\n            int largestOrSmallestIndex = rootIndex;\n\n            if (asc) { // For ascending sort, build a max-heap\n                if (leftChildIndex < currentHeapSize && result[leftChildIndex] > result[largestOrSmallestIndex]) {\n                    largestOrSmallestIndex = leftChildIndex;\n                }\n                if (rightChildIndex < currentHeapSize && result[rightChildIndex] > result[largestOrSmallestIndex]) {\n                    largestOrSmallestIndex = rightChildIndex;\n                }\n            } else { // For descending sort, build a min-heap\n                if (leftChildIndex < currentHeapSize && result[leftChildIndex] < result[largestOrSmallestIndex]) {\n                    largestOrSmallestIndex = leftChildIndex;\n                }\n                if (rightChildIndex < currentHeapSize && result[rightChildIndex] < result[largestOrSmallestIndex]) {\n                    largestOrSmallestIndex = rightChildIndex;\n                }\n            }\n\n            if (largestOrSmallestIndex != rootIndex) {\n                // Swap elements\n                int temp = result[rootIndex];\n                result[rootIndex] = result[largestOrSmallestIndex];\n                result[largestOrSmallestIndex] = temp;\n                rootIndex = largestOrSmallestIndex; // Continue sifting down\n            } else {\n                break; // Element is in its correct heap position\n            }\n        }\n    }\n\n    // One by one extract an element from heap\n    // Move current root to end, then re-heapify the remaining elements\n    for (int i = n - 1; i > 0; i--) {\n        // Move current root (largest/smallest element) to the end of the unsorted part\n        int temp = result[0];\n        result[0] = result[i];\n        result[i] = temp;\n\n        int rootIndex = 0;\n        int currentHeapSize = i; // The heap size decreases with each extracted element\n\n        // Inlined siftDown logic for the reduced heap\n        while (true) {\n            int leftChildIndex = 2 * rootIndex + 1;\n            int rightChildIndex = 2 * rootIndex + 2;\n            int largestOrSmallestIndex = rootIndex;\n\n            if (asc) { // For ascending sort, maintain a max-heap\n                if (leftChildIndex < currentHeapSize && result[leftChildIndex] > result[largestOrSmallestIndex]) {\n                    largestOrSmallestIndex = leftChildIndex;\n                }\n                if (rightChildIndex < currentHeapSize && result[rightChildIndex] > result[largestOrSmallestIndex]) {\n                    largestOrSmallestIndex = rightChildIndex;\n                }\n            } else { // For descending sort, maintain a min-heap\n                if (leftChildIndex < currentHeapSize && result[leftChildIndex] < result[largestOrSmallestIndex]) {\n                    largestOrSmallestIndex = leftChildIndex;\n                }\n                if (rightChildIndex < currentHeapSize && result[rightChildIndex] < result[largestOrSmallestIndex]) {\n                    largestOrSmallestIndex = rightChildIndex;\n                }\n            }\n\n            if (largestOrSmallestIndex != rootIndex) {\n                // Swap elements\n                int temp2 = result[rootIndex];\n                result[rootIndex] = result[largestOrSmallestIndex];\n                result[largestOrSmallestIndex] = temp2;\n                rootIndex = largestOrSmallestIndex; // Continue sifting down\n            } else {\n                break; // Element is in its correct heap position\n            }\n        }\n    }\n\n    return result;\n}",
  "sinceUse": 0
}]