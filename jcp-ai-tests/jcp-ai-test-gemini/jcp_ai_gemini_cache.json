[{
  "uuid": "5b4303f9-7144-4020-a9eb-5731a6ce2a77",
  "instant": "2025-07-21T21:43:20.666758519Z",
  "key": "tBeMqvVnM5QcBjUZ/+TxUZ6Fl+/Mojpm7a+Nw6rseeIua7lxs8DAJtOsc4M7um0lgBrmDWVfckUOuhfeVo2rLvc7R4KnHfmNwLY/CnFovNs=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts an array of integers using a highly optimized Quicksort algorithm.\n * This method prioritizes speed and minimizes memory overhead.\n * It handles null, empty, or single-element arrays by returning them directly.\n * For arrays requiring sorting, a new sorted array is returned.\n * The implementation is entirely self-contained, without external libraries or helper methods.\n *\n * @param array The array of integers to be sorted.\n * @param asc   If true, sort in ascending order; otherwise, sort in descending order.\n * @return A new array with sorted values, or the original array if it's null, empty, or contains a single element.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int[] result = new int[array.length];\n    java.lang.System.arraycopy(array, 0, result, 0, array.length);\n\n    // Stack for iterative Quicksort to manage sub-array ranges.\n    // A fixed size of 64 is sufficient for typical array sizes with the tail recursion optimization,\n    // as log2(Integer.MAX_VALUE) is approximately 31.\n    int[] stackLow = new int[64];\n    int[] stackHigh = new int[64];\n    int stackPointer = 0;\n\n    // Push the initial range onto the stack\n    stackLow[stackPointer] = 0;\n    stackHigh[stackPointer] = result.length - 1;\n    stackPointer++;\n\n    // Main loop for iterative Quicksort\n    while (stackPointer > 0) {\n        // Pop a range from the stack\n        stackPointer--;\n        int low = stackLow[stackPointer];\n        int high = stackHigh[stackPointer];\n\n        // Use Insertion Sort for small sub-arrays (improves performance due to lower overhead)\n        // Threshold of 16 is a common optimization.\n        if (high - low + 1 < 16) {\n            for (int i = low + 1; i <= high; i++) {\n                int key = result[i];\n                int j = i - 1;\n                if (asc) {\n                    while (j >= low && result[j] > key) {\n                        result[j + 1] = result[j];\n                        j--;\n                    }\n                } else { // Descending order\n                    while (j >= low && result[j] < key) {\n                        result[j + 1] = result[j];\n                        j--;\n                    }\n                }\n                result[j + 1] = key;\n            }\n            continue; // Move to the next range on the stack\n        }\n\n        // Quicksort Partitioning (Lomuto-like with median-of-three pivot selection)\n        // Choose median-of-three as pivot to mitigate worst-case O(N^2) scenarios\n        int mid = low + (high - low) / 2;\n\n        // Sort result[low], result[mid], result[high] to place the median at result[mid]\n        if (asc) {\n            if (result[low] > result[mid]) { int temp = result[low]; result[low] = result[mid]; result[mid] = temp; }\n            if (result[low] > result[high]) { int temp = result[low]; result[low] = result[high]; result[high] = temp; }\n            if (result[mid] > result[high]) { int temp = result[mid]; result[mid] = result[high]; result[high] = temp; }\n        } else { // Descending order\n            if (result[low] < result[mid]) { int temp = result[low]; result[low] = result[mid]; result[mid] = temp; }\n            if (result[low] < result[high]) { int temp = result[low]; result[low] = result[high]; result[high] = temp; }\n            if (result[mid] < result[high]) { int temp = result[mid]; result[mid] = result[high]; result[high] = temp; }\n        }\n\n        // Move the pivot (now at mid) to the end of the current sub-array (result[high])\n        int tempPivot = result[mid];\n        result[mid] = result[high];\n        result[high] = tempPivot;\n        int pivotValue = result[high]; // Pivot is now at result[high]\n\n        // Partition the array elements from low to high-1 around the pivot\n        int i = low - 1; // Pointer for elements smaller/larger than pivot\n        for (int j = low; j < high; j++) {\n            if ((asc && result[j] <= pivotValue) || (!asc && result[j] >= pivotValue)) {\n                i++;\n                int temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n\n        // Place the pivot in its correct sorted position\n        int partitionIndex = i + 1;\n        int temp = result[partitionIndex];\n        result[partitionIndex] = result[high];\n        result[high] = temp;\n\n        // Push sub-arrays to stack for processing, applying tail recursion optimization.\n        // The smaller sub-array is pushed to the stack, and the larger one is processed\n        // iteratively in the current loop iteration. This keeps the stack depth O(log N).\n        if (partitionIndex - 1 - low > high - (partitionIndex + 1)) { // Left part is larger\n            // Push right part if it's a valid range\n            if (partitionIndex + 1 <= high) {\n                stackLow[stackPointer] = partitionIndex + 1;\n                stackHigh[stackPointer] = high;\n                stackPointer++;\n            }\n            // Process left part iteratively by updating 'high' for the next loop iteration\n            high = partitionIndex - 1;\n        } else { // Right part is larger or equal\n            // Push left part if it's a valid range\n            if (low <= partitionIndex - 1) {\n                stackLow[stackPointer] = low;\n                stackHigh[stackPointer] = partitionIndex - 1;\n                stackPointer++;\n            }\n            // Process right part iteratively by updating 'low' for the next loop iteration\n            low = partitionIndex + 1;\n        }\n\n        // If the current range became invalid (e.g., low > high) after processing one side,\n        // continue to the next range from the stack. Otherwise, the loop naturally\n        // re-evaluates with the updated 'low' and 'high' for the larger partition.\n        if (low > high) {\n            continue;\n        }\n        // The loop will continue with the new (low, high) for the larger partition,\n        // effectively making the larger recursive call iterative.\n    }\n\n    return result;\n}"
}]