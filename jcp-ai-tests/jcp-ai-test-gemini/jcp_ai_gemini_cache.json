[
  {
    "instant": "2025-08-13T10:41:00.335651313Z",
    "key": "kCeQN6mLC/K4LPKNoh4QmIU1tNcH3o6NdysdIDNsL5U/TR55YTRMIjNI2NVGpaN0S0/rdZa4yk2ldIZsQBZFasFkxJ1DUtzGR2NVEq9U238\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts an array of integers using an optimized iterative QuickSort algorithm.\n * This method prioritizes speed and uses minimal memory overhead.\n * It includes an Insertion Sort fallback for small partitions to improve performance.\n *\n * @param array The array of integers to be sorted.\n * @param asc   If true, the array will be sorted in ascending order; otherwise, in descending order.\n * @return A new array with sorted values. Returns the original array if it is null, empty, or contains a single value.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) {\n        return array;\n    }\n\n    int[] resultArray \u003d java.util.Arrays.copyOf(array, array.length);\n\n    int[] stack \u003d new int[2 * resultArray.length];\n    int top \u003d -1;\n\n    stack[++top] \u003d 0;\n    stack[++top] \u003d resultArray.length - 1;\n\n    final int INSERTION_SORT_THRESHOLD \u003d 16;\n\n    while (top \u003e\u003d 0) {\n        int high \u003d stack[top--];\n        int low \u003d stack[top--];\n\n        if (high - low + 1 \u003c INSERTION_SORT_THRESHOLD) {\n            for (int k \u003d low + 1; k \u003c\u003d high; k++) {\n                int key \u003d resultArray[k];\n                int l \u003d k - 1;\n                if (asc) {\n                    while (l \u003e\u003d low \u0026\u0026 resultArray[l] \u003e key) {\n                        resultArray[l + 1] \u003d resultArray[l];\n                        l--;\n                    }\n                } else {\n                    while (l \u003e\u003d low \u0026\u0026 resultArray[l] \u003c key) {\n                        resultArray[l + 1] \u003d resultArray[l];\n                        l--;\n                    }\n                }\n                resultArray[l + 1] \u003d key;\n            }\n            continue;\n        }\n\n        int pivot \u003d resultArray[high];\n        int i \u003d low - 1;\n\n        for (int j \u003d low; j \u003c high; j++) {\n            boolean condition \u003d asc ? (resultArray[j] \u003c\u003d pivot) : (resultArray[j] \u003e\u003d pivot);\n            if (condition) {\n                i++;\n                int temp \u003d resultArray[i];\n                resultArray[i] \u003d resultArray[j];\n                resultArray[j] \u003d temp;\n            }\n        }\n\n        int temp \u003d resultArray[i + 1];\n        resultArray[i + 1] \u003d resultArray[high];\n        resultArray[high] \u003d temp;\n\n        int partitionIndex \u003d i + 1;\n\n        if (partitionIndex - 1 - low \u003e high - (partitionIndex + 1)) {\n            stack[++top] \u003d low;\n            stack[++top] \u003d partitionIndex - 1;\n            stack[++top] \u003d partitionIndex + 1;\n            stack[++top] \u003d high;\n        } else {\n            stack[++top] \u003d partitionIndex + 1;\n            stack[++top] \u003d high;\n            stack[++top] \u003d low;\n            stack[++top] \u003d partitionIndex - 1;\n        }\n    }\n\n    return resultArray;\n}",
    "sinceUse": 0
  }
]