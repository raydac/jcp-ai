[
  {
    "instant": "2025-08-19T05:54:57.008595241Z",
    "key": "kCeQN6mLC/K4LPKNoh4QmIU1tNcH3o6NdysdIDNsL5U/TR55YTRMIjNI2NVGpaN0S0/rdZa4yk2ldIZsQBZFasFkxJ1DUtzGR2NVEq9U238\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts an array of integers using the Heapsort algorithm, which provides O(N log N) time complexity\n * and O(1) auxiliary space complexity, making it efficient in terms of both speed and memory overhead.\n * The method handles null, empty, or single-element arrays by returning them directly.\n * For arrays with multiple elements, it returns a new array containing the sorted values.\n *\n * @param array The array of integers to be sorted.\n * @param asc   If true, the array will be sorted in ascending order; otherwise, in descending order.\n * @return A new array with sorted values, or the original array if it was null, empty, or contained a single element.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) {\n        return array;\n    }\n\n    int[] result \u003d java.util.Arrays.copyOf(array, array.length);\n    int n \u003d result.length;\n\n    for (int i \u003d n / 2 - 1; i \u003e\u003d 0; i--) {\n        int root \u003d i;\n        while (true) {\n            int leftChild \u003d 2 * root + 1;\n            int rightChild \u003d 2 * root + 2;\n            int largest \u003d root;\n\n            if (leftChild \u003c n \u0026\u0026 result[leftChild] \u003e result[largest]) {\n                largest \u003d leftChild;\n            }\n            if (rightChild \u003c n \u0026\u0026 result[rightChild] \u003e result[largest]) {\n                largest \u003d rightChild;\n            }\n\n            if (largest !\u003d root) {\n                int swap \u003d result[root];\n                result[root] \u003d result[largest];\n                result[largest] \u003d swap;\n                root \u003d largest;\n            } else {\n                break;\n            }\n        }\n    }\n\n    for (int i \u003d n - 1; i \u003e 0; i--) {\n        int temp \u003d result[0];\n        result[0] \u003d result[i];\n        result[i] \u003d temp;\n\n        int root \u003d 0;\n        int currentHeapSize \u003d i;\n        while (true) {\n            int leftChild \u003d 2 * root + 1;\n            int rightChild \u003d 2 * root + 2;\n            int largest \u003d root;\n\n            if (leftChild \u003c currentHeapSize \u0026\u0026 result[leftChild] \u003e result[largest]) {\n                largest \u003d leftChild;\n            }\n            if (rightChild \u003c currentHeapSize \u0026\u0026 result[rightChild] \u003e result[largest]) {\n                largest \u003d rightChild;\n            }\n\n            if (largest !\u003d root) {\n                int swap \u003d result[root];\n                result[root] \u003d result[largest];\n                result[largest] \u003d swap;\n                root \u003d largest;\n            } else {\n                break;\n            }\n        }\n    }\n\n    if (!asc) {\n        for (int i \u003d 0; i \u003c n / 2; i++) {\n            int temp \u003d result[i];\n            result[i] \u003d result[n - 1 - i];\n            result[n - 1 - i] \u003d temp;\n        }\n    }\n\n    return result;\n}",
    "sinceUse": 0
  }
]