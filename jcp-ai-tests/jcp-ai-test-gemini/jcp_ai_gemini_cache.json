[{
  "instant": "2025-08-09T17:19:36.026124066Z",
  "key": "kCeQN6mLC/K4LPKNoh4QmIU1tNcH3o6NdysdIDNsL5U/TR55YTRMIjNI2NVGpaN0S0/rdZa4yk2ldIZsQBZFasFkxJ1DUtzGR2NVEq9U238=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts an array of integers using an iterative QuickSort algorithm.\n * This method prioritizes speed and has minimal memory overhead,\n * implementing the sorting logic entirely within itself without external\n * libraries or helper methods.\n *\n * @param array The array of integers to be sorted.\n * @param asc   If true, sorts in ascending order; otherwise, sorts in descending order.\n * @return A new array with sorted values, or the original array if it is null, empty, or contains a single value.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int[] sortedArray = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        sortedArray[i] = array[i];\n    }\n\n    int[] stack = new int[sortedArray.length * 2];\n    int top = -1;\n\n    stack[++top] = 0;\n    stack[++top] = sortedArray.length - 1;\n\n    while (top >= 0) {\n        int high = stack[top--];\n        int low = stack[top--];\n\n        while (low < high) {\n            int pivot = sortedArray[high];\n            int i = low - 1;\n\n            for (int j = low; j < high; j++) {\n                if (asc ? (sortedArray[j] <= pivot) : (sortedArray[j] >= pivot)) {\n                    i++;\n                    int temp = sortedArray[i];\n                    sortedArray[i] = sortedArray[j];\n                    sortedArray[j] = temp;\n                }\n            }\n\n            int temp = sortedArray[i+1];\n            sortedArray[i+1] = sortedArray[high];\n            sortedArray[high] = temp;\n\n            int partitionIndex = i + 1;\n\n            if (partitionIndex - low < high - partitionIndex) {\n                stack[++top] = partitionIndex + 1;\n                stack[++top] = high;\n                high = partitionIndex - 1;\n            } else {\n                stack[++top] = low;\n                stack[++top] = partitionIndex - 1;\n                low = partitionIndex + 1;\n            }\n        }\n    }\n\n    return sortedArray;\n}",
  "sinceUse": 0
}]