[{
  "uuid": "dc253d18-a1d1-4385-a649-b0dc4c45dfdc",
  "instant": "2025-07-22T07:04:34.915744464Z",
  "key": "tBeMqvVnM5QcBjUZ/+TxUZ6Fl+/Mojpm7a+Nw6rseeIua7lxs8DAJtOsc4M7um0lgBrmDWVfckUOuhfeVo2rLvc7R4KnHfmNwLY/CnFovNs=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts an array of integers using an iterative Dual-Pivot Quicksort algorithm.\n * This method prioritizes speed and minimal memory overhead.\n * It implements the sorting logic entirely within this single method,\n * without relying on external helper methods or utility classes.\n *\n * @param array The array to be sorted.\n * @param asc   If true, sort in ascending order; otherwise, sort in descending order.\n * @return The same incoming array if it is null, empty, or a single-value array.\n *         Otherwise, returns a new version of the array with sorted values.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int[] result = new int[array.length];\n    java.lang.System.arraycopy(array, 0, result, 0, array.length);\n\n    java.util.ArrayDeque<int[]> stack = new java.util.ArrayDeque<>();\n    stack.push(new int[]{0, result.length - 1});\n\n    while (!stack.isEmpty()) {\n        int[] range = stack.pop();\n        int left = range[0];\n        int right = range[1];\n\n        if (left >= right) {\n            continue;\n        }\n\n        int pivot1 = result[left];\n        int pivot2 = result[right];\n\n        if (asc) {\n            if (pivot1 > pivot2) {\n                int temp = result[left];\n                result[left] = result[right];\n                result[right] = temp;\n                pivot1 = result[left];\n                pivot2 = result[right];\n            }\n        } else {\n            if (pivot1 < pivot2) {\n                int temp = result[left];\n                result[left] = result[right];\n                result[right] = temp;\n                pivot1 = result[left];\n                pivot2 = result[right];\n            }\n        }\n\n        int lt = left + 1;\n        int gt = right - 1;\n        int i = lt;\n\n        while (i <= gt) {\n            int currentVal = result[i];\n            if (asc) {\n                if (currentVal < pivot1) {\n                    int temp = result[i];\n                    result[i] = result[lt];\n                    result[lt] = temp;\n                    lt++;\n                    i++;\n                } else if (currentVal > pivot2) {\n                    int temp = result[i];\n                    result[i] = result[gt];\n                    result[gt] = temp;\n                    gt--;\n                } else {\n                    i++;\n                }\n            } else {\n                if (currentVal > pivot1) {\n                    int temp = result[i];\n                    result[i] = result[lt];\n                    result[lt] = temp;\n                    lt++;\n                    i++;\n                } else if (currentVal < pivot2) {\n                    int temp = result[i];\n                    result[i] = result[gt];\n                    result[gt] = temp;\n                    gt--;\n                } else {\n                    i++;\n                }\n            }\n        }\n\n        int temp = result[left];\n        result[left] = result[lt - 1];\n        result[lt - 1] = temp;\n\n        temp = result[right];\n        result[right] = result[gt + 1];\n        result[gt + 1] = temp;\n\n        if (gt + 2 < right) {\n            stack.push(new int[]{gt + 2, right});\n        }\n        if (lt < gt) {\n            stack.push(new int[]{lt, gt});\n        }\n        if (left < lt - 1) {\n            stack.push(new int[]{left, lt - 2});\n        }\n    }\n\n    return result;\n}"
}]