[{
  "uuid": "5a430bb7-66ae-4da1-a375-30f253ec6cb0",
  "instant": "2025-08-02T19:16:12.074182007Z",
  "key": "kCeQN6mLC/K4LPKNoh4QmIU1tNcH3o6NdysdIDNsL5U/TR55YTRMIjNI2NVGpaN0S0/rdZa4yk2ldIZsQBZFasFkxJ1DUtzGR2NVEq9U238=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts an array of integers using a HeapSort algorithm.\n * This method prioritizes speed and uses minimal memory overhead (O(1) auxiliary space beyond the initial array copy).\n * It does not use any external libraries or helper methods, implementing the entire sorting logic within itself.\n *\n * @param array The array of integers to be sorted.\n * @param asc   If true, the array will be sorted in ascending order; otherwise, in descending order.\n * @return The sorted array. Returns the original array instance if it is null, empty, or contains a single element.\n *         Otherwise, returns a new array instance with the sorted values.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int[] result = new int[array.length];\n    java.lang.System.arraycopy(array, 0, result, 0, array.length);\n\n    int n = result.length;\n\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        int root = i;\n        while (true) {\n            int leftChild = 2 * root + 1;\n            int rightChild = 2 * root + 2;\n            int targetIndex = root;\n\n            if (asc) {\n                if (leftChild < n && result[leftChild] > result[targetIndex]) {\n                    targetIndex = leftChild;\n                }\n                if (rightChild < n && result[rightChild] > result[targetIndex]) {\n                    targetIndex = rightChild;\n                }\n            } else {\n                if (leftChild < n && result[leftChild] < result[targetIndex]) {\n                    targetIndex = leftChild;\n                }\n                if (rightChild < n && result[rightChild] < result[targetIndex]) {\n                    targetIndex = rightChild;\n                }\n            }\n\n            if (targetIndex != root) {\n                int swap = result[root];\n                result[root] = result[targetIndex];\n                result[targetIndex] = swap;\n                root = targetIndex;\n            } else {\n                break;\n            }\n        }\n    }\n\n    for (int i = n - 1; i > 0; i--) {\n        int temp = result[0];\n        result[0] = result[i];\n        result[i] = temp;\n\n        int root = 0;\n        int currentHeapSize = i;\n        while (true) {\n            int leftChild = 2 * root + 1;\n            int rightChild = 2 * root + 2;\n            int targetIndex = root;\n\n            if (asc) {\n                if (leftChild < currentHeapSize && result[leftChild] > result[targetIndex]) {\n                    targetIndex = leftChild;\n                }\n                if (rightChild < currentHeapSize && result[rightChild] > result[targetIndex]) {\n                    targetIndex = rightChild;\n                }\n            } else {\n                if (leftChild < currentHeapSize && result[leftChild] < result[targetIndex]) {\n                    targetIndex = leftChild;\n                }\n                if (rightChild < currentHeapSize && result[rightChild] < result[targetIndex]) {\n                    targetIndex = rightChild;\n                }\n            }\n\n            if (targetIndex != root) {\n                int swap = result[root];\n                result[root] = result[targetIndex];\n                result[targetIndex] = swap;\n                root = targetIndex;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return result;\n}",
  "sinceUse": 0
}]