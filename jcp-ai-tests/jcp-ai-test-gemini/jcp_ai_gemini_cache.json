[{
  "uuid": "31293711-460f-4f34-8d7c-7fc59234f50c",
  "instant": "2025-08-01T22:54:29.961715380Z",
  "key": "tBeMqvVnM5QcBjUZ/+TxUZ6Fl+/Mojpm7a+Nw6rseeIua7lxs8DAJtOsc4M7um0lgBrmDWVfckUOuhfeVo2rLvc7R4KnHfmNwLY/CnFovNs=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts an array of integers using an iterative QuickSort algorithm.\n * This method prioritizes speed and aims for minimal memory overhead for the sorting process itself,\n * while adhering to the constraint of being a single method without additional helper functions.\n *\n * If the input array is null, empty, or contains a single element, the original array is returned.\n * Otherwise, a new array containing the sorted values is returned.\n *\n * @param array The array of integers to be sorted.\n * @param asc If true, the array will be sorted in ascending order; otherwise, in descending order.\n * @return A new array with sorted values, or the original array if it's null, empty, or single-valued.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int[] result = java.util.Arrays.copyOf(array, array.length);\n\n    java.util.Stack<Integer> stack = new java.util.Stack<>();\n    stack.push(0);\n    stack.push(result.length - 1);\n\n    while (!stack.isEmpty()) {\n        int high = stack.pop();\n        int low = stack.pop();\n\n        if (low < high) {\n            int pivotValue = result[high];\n            int i = low - 1;\n\n            for (int j = low; j < high; j++) {\n                boolean condition;\n                if (asc) {\n                    condition = result[j] <= pivotValue;\n                } else {\n                    condition = result[j] >= pivotValue;\n                }\n\n                if (condition) {\n                    i++;\n                    int temp = result[i];\n                    result[i] = result[j];\n                    result[j] = temp;\n                }\n            }\n\n            int partitionIndex = i + 1;\n            int temp = result[partitionIndex];\n            result[partitionIndex] = result[high];\n            result[high] = temp;\n\n            int leftSubarraySize = partitionIndex - low;\n            int rightSubarraySize = high - partitionIndex;\n\n            if (leftSubarraySize > rightSubarraySize) {\n                stack.push(low);\n                stack.push(partitionIndex - 1);\n                stack.push(partitionIndex + 1);\n                stack.push(high);\n            } else {\n                stack.push(partitionIndex + 1);\n                stack.push(high);\n                stack.push(low);\n                stack.push(partitionIndex - 1);\n            }\n        }\n    }\n\n    return result;\n}",
  "sinceUse": 0
}]