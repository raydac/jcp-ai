[{
  "uuid": "1819ea00-d06b-4ac3-afa9-1e662c2519ff",
  "instant": "2025-07-27T12:30:51.768819046Z",
  "key": "tBeMqvVnM5QcBjUZ/+TxUZ6Fl+/Mojpm7a+Nw6rseeIua7lxs8DAJtOsc4M7um0lgBrmDWVfckUOuhfeVo2rLvc7R4KnHfmNwLY/CnFovNs=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts an array of integers using the Heapsort algorithm, which provides O(N log N) time complexity\n * and O(1) auxiliary space complexity. The method ensures that the original array is not modified\n * unless it is null, empty, or contains a single element.\n *\n * @param array The array of integers to be sorted.\n * @param asc   If true, the array will be sorted in ascending order; otherwise, in descending order.\n * @return A new array with sorted values if the input array has more than one element;\n *         otherwise, the original array reference is returned (if null, empty, or single-element).\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array == null || array.length <= 1) {\n        return array;\n    }\n\n    int n = array.length;\n    int[] result = new int[n];\n\n    // Manually copy array elements to the new result array\n    for (int i = 0; i < n; i++) {\n        result[i] = array[i];\n    }\n\n    // Phase 1: Build a Max-Heap (for ascending sort)\n    // Iterate from the last non-leaf node up to the root\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        int rootIndex = i;\n        // Inlined iterative heapify process for building the heap\n        while (true) {\n            int largest = rootIndex;\n            int leftChild = 2 * rootIndex + 1;\n            int rightChild = 2 * rootIndex + 2;\n\n            // If left child is larger than current largest\n            if (leftChild < n && result[leftChild] > result[largest]) {\n                largest = leftChild;\n            }\n\n            // If right child is larger than current largest\n            if (rightChild < n && result[rightChild] > result[largest]) {\n                largest = rightChild;\n            }\n\n            // If largest is not the root, swap and continue heapifying down\n            if (largest != rootIndex) {\n                int swap = result[rootIndex];\n                result[rootIndex] = result[largest];\n                result[largest] = swap;\n                rootIndex = largest; // Move down to the child that was swapped\n            } else {\n                break; // Heap property satisfied for this subtree\n            }\n        }\n    }\n\n    // Phase 2: Extract elements from heap one by one\n    // Iterate from the last element down to the second element\n    for (int i = n - 1; i > 0; i--) {\n        // Move current root (largest element) to end of array\n        int swap = result[0];\n        result[0] = result[i];\n        result[i] = swap;\n\n        // Inlined iterative heapify process for the reduced heap\n        int rootIndex = 0;\n        int currentHeapSize = i; // The heap size decreases with each extraction\n        while (true) {\n            int largest = rootIndex;\n            int leftChild = 2 * rootIndex + 1;\n            int rightChild = 2 * rootIndex + 2;\n\n            // If left child is larger than current largest\n            if (leftChild < currentHeapSize && result[leftChild] > result[largest]) {\n                largest = leftChild;\n            }\n\n            // If right child is larger than current largest\n            if (rightChild < currentHeapSize && result[rightChild] > result[largest]) {\n                largest = rightChild;\n            }\n\n            // If largest is not the root, swap and continue heapifying down\n            if (largest != rootIndex) {\n                int temp = result[rootIndex];\n                result[rootIndex] = result[largest];\n                result[largest] = temp;\n                rootIndex = largest; // Move down to the child that was swapped\n            } else {\n                break; // Heap property satisfied for this subtree\n            }\n        }\n    }\n\n    // Handle descending order if requested\n    if (!asc) {\n        for (int i = 0; i < n / 2; i++) {\n            int temp = result[i];\n            result[i] = result[n - 1 - i];\n            result[n - 1 - i] = temp;\n        }\n    }\n\n    return result;\n}",
  "sinceUse": 0
}]