[
  {
    "instant": "2025-09-02T19:50:35.882401257Z",
    "key": "kCeQN6mLC/K4LPKNoh4QmIU1tNcH3o6NdysdIDNsL5U/TR55YTRMIjNI2NVGpaN0S0/rdZa4yk2ldIZsQBZFasFkxJ1DUtzGR2NVEq9U238\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts an array of integers using an iterative QuickSort algorithm.\n * This method prioritizes speed and uses minimal memory overhead beyond the necessary array copy.\n * It does not use any external libraries or additional helper methods, implementing the\n * entire sorting logic within this single method.\n *\n * @param array The array of integers to be sorted.\n * @param asc   If true, the array will be sorted in ascending order; otherwise, in descending order.\n * @return A new array containing the sorted values. Returns the original array reference if\n *         the input array is null, empty, or contains only one element.\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) {\n        return array;\n    }\n\n    int[] sortedArray \u003d java.util.Arrays.copyOf(array, array.length);\n\n    java.util.ArrayDeque\u003cint[]\u003e stack \u003d new java.util.ArrayDeque\u003c\u003e();\n    stack.push(new int[]{0, sortedArray.length - 1});\n\n    while (!stack.isEmpty()) {\n        int[] range \u003d stack.pop();\n        int low \u003d range[0];\n        int high \u003d range[1];\n\n        if (low \u003c high) {\n            int pivot \u003d sortedArray[high];\n            int i \u003d low - 1;\n\n            for (int j \u003d low; j \u003c high; j++) {\n                boolean condition \u003d asc ? (sortedArray[j] \u003c\u003d pivot) : (sortedArray[j] \u003e\u003d pivot);\n                if (condition) {\n                    i++;\n                    int temp \u003d sortedArray[i];\n                    sortedArray[i] \u003d sortedArray[j];\n                    sortedArray[j] \u003d temp;\n                }\n            }\n\n            int pivotIndex \u003d i + 1;\n            int temp \u003d sortedArray[pivotIndex];\n            sortedArray[pivotIndex] \u003d sortedArray[high];\n            sortedArray[high] \u003d temp;\n\n            if (pivotIndex - 1 - low \u003e high - (pivotIndex + 1)) {\n                stack.push(new int[]{low, pivotIndex - 1});\n                stack.push(new int[]{pivotIndex + 1, high});\n            } else {\n                stack.push(new int[]{pivotIndex + 1, high});\n                stack.push(new int[]{low, pivotIndex - 1});\n            }\n        }\n    }\n\n    return sortedArray;\n}",
    "sinceUse": 0
  }
]