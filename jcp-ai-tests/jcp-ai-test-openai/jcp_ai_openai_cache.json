[
  {
    "instant": "2025-09-30T17:59:28.655598751Z",
    "key": "xSJc9S+tkUTe8REi08LfsXBzuUldeD9UjZucW1PC/A/tGfR/nE+zXqZnzr5Swm7V+1cvFUHskL+A3rd6e9yQISAFtrh83GSDiyTPrm52r9U\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts the given array of integers using a high-performance, low-overhead algorithm.\n * Returns the same array instance if it is null, empty, or has a single element.\n * Otherwise, returns a new array containing the sorted values.\n * Sorting order is ascending if asc is true, descending otherwise.\n *\n * @param array the input array to sort\n * @param asc true for ascending order, false for descending\n * @return a sorted array, or the original array if null/empty/singleton\n */\npublic static int [] fastSort(final int [] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c 2) return array;\n    final int[] a \u003d array.clone();\n    final int n \u003d a.length;\n    final int threshold \u003d 24;\n    int depthLimit \u003d 2 * (31 - Integer.numberOfLeadingZeros(n));\n    int[] stack \u003d new int[(depthLimit + 32) * 3];\n    int top \u003d 0;\n    int lo \u003d 0, hi \u003d n - 1, d \u003d depthLimit;\n    while (true) {\n        int size \u003d hi - lo + 1;\n        if (size \u003c\u003d threshold) {\n            for (int i \u003d lo + 1; i \u003c\u003d hi; i++) {\n                int v \u003d a[i];\n                int j \u003d i - 1;\n                while (j \u003e\u003d lo \u0026\u0026 a[j] \u003e v) {\n                    a[j + 1] \u003d a[j];\n                    j--;\n                }\n                a[j + 1] \u003d v;\n            }\n            if (top \u003d\u003d 0) break;\n            top -\u003d 3;\n            lo \u003d stack[top];\n            hi \u003d stack[top + 1];\n            d \u003d stack[top + 2];\n            continue;\n        }\n        if (d \u003d\u003d 0) {\n            int base \u003d lo;\n            int len \u003d size;\n            for (int i \u003d (len \u003e\u003e\u003e 1) - 1; i \u003e\u003d 0; i--) {\n                int ii \u003d i;\n                int v \u003d a[base + ii];\n                int j;\n                while ((j \u003d (ii \u003c\u003c 1) + 1) \u003c len) {\n                    int k \u003d j + 1;\n                    int child \u003d j;\n                    int cj \u003d a[base + j];\n                    if (k \u003c len) {\n                        int ck \u003d a[base + k];\n                        if (cj \u003c ck) { child \u003d k; cj \u003d ck; }\n                    }\n                    if (cj \u003c\u003d v) break;\n                    a[base + ii] \u003d cj;\n                    ii \u003d child;\n                }\n                a[base + ii] \u003d v;\n            }\n            for (int end \u003d len - 1; end \u003e 0; end--) {\n                int tmp \u003d a[base + end];\n                a[base + end] \u003d a[base];\n                a[base] \u003d tmp;\n                int ii \u003d 0;\n                int v \u003d a[base + ii];\n                int j;\n                int lim \u003d end;\n                while ((j \u003d (ii \u003c\u003c 1) + 1) \u003c lim) {\n                    int k \u003d j + 1;\n                    int child \u003d j;\n                    int cj \u003d a[base + j];\n                    if (k \u003c lim) {\n                        int ck \u003d a[base + k];\n                        if (cj \u003c ck) { child \u003d k; cj \u003d ck; }\n                    }\n                    if (cj \u003c\u003d v) break;\n                    a[base + ii] \u003d cj;\n                    ii \u003d child;\n                }\n                a[base + ii] \u003d v;\n            }\n            if (top \u003d\u003d 0) break;\n            top -\u003d 3;\n            lo \u003d stack[top];\n            hi \u003d stack[top + 1];\n            d \u003d stack[top + 2];\n            continue;\n        }\n        int mid \u003d lo + ((hi - lo) \u003e\u003e\u003e 1);\n        int l \u003d a[lo], m \u003d a[mid], h \u003d a[hi];\n        if (l \u003e m) { int t \u003d a[lo]; a[lo] \u003d a[mid]; a[mid] \u003d t; l \u003d a[lo]; m \u003d a[mid]; }\n        if (m \u003e h) { int t \u003d a[mid]; a[mid] \u003d a[hi]; a[hi] \u003d t; m \u003d a[mid]; h \u003d a[hi]; if (l \u003e m) { int tt \u003d a[lo]; a[lo] \u003d a[mid]; a[mid] \u003d tt; l \u003d a[lo]; m \u003d a[mid]; } }\n        int pivot \u003d m;\n        int i \u003d lo, lt \u003d lo, gt \u003d hi;\n        while (i \u003c\u003d gt) {\n            int v \u003d a[i];\n            if (v \u003c pivot) { int t \u003d a[lt]; a[lt] \u003d v; a[i] \u003d t; lt++; i++; }\n            else if (v \u003e pivot) { int t \u003d a[i]; a[i] \u003d a[gt]; a[gt] \u003d t; gt--; }\n            else { i++; }\n        }\n        d--;\n        int leftLo \u003d lo, leftHi \u003d lt - 1;\n        int rightLo \u003d gt + 1, rightHi \u003d hi;\n        int leftSize \u003d leftHi - leftLo + 1;\n        int rightSize \u003d rightHi - rightLo + 1;\n        if (leftSize \u003e rightSize) {\n            if (leftSize \u003e 0) { stack[top++] \u003d leftLo; stack[top++] \u003d leftHi; stack[top++] \u003d d; }\n            if (rightSize \u003e 0) { lo \u003d rightLo; hi \u003d rightHi; continue; }\n        } else {\n            if (rightSize \u003e 0) { stack[top++] \u003d rightLo; stack[top++] \u003d rightHi; stack[top++] \u003d d; }\n            if (leftSize \u003e 0) { lo \u003d leftLo; hi \u003d leftHi; continue; }\n        }\n        if (top \u003d\u003d 0) break;\n        top -\u003d 3;\n        lo \u003d stack[top];\n        hi \u003d stack[top + 1];\n        d \u003d stack[top + 2];\n    }\n    if (!asc) {\n        for (int i \u003d 0, j \u003d n - 1; i \u003c j; i++, j--) {\n            int t \u003d a[i]; a[i] \u003d a[j]; a[j] \u003d t;\n        }\n    }\n    return a;\n}",
    "sinceUse": 0
  }
]