[
  {
    "instant": "2025-10-05T14:52:40.567154131Z",
    "key": "xSJc9S+tkUTe8REi08LfsXBzuUldeD9UjZucW1PC/A/tGfR/nE+zXqZnzr5Swm7V+1cvFUHskL+A3rd6e9yQISAFtrh83GSDiyTPrm52r9U\u003d",
    "fileName": "ArraySorter.java",
    "line": 24,
    "result": "/**\n * Sorts the given int array using a high-performance in-place 3-way quicksort with median-of-three pivot selection\n * and an insertion sort fallback for small partitions. For speed and minimal memory overhead, partitioning is done\n * iteratively with a manual stack and tail-recursion elimination.\n *\n * The method returns:\n * - The same array instance if it is null, empty, or contains a single element.\n * - A new array instance (a clone of the input) with sorted values otherwise.\n *\n * Sorting order is ascending when asc is true, descending otherwise.\n *\n * @param array the array to be sorted\n * @param asc true for ascending order, false for descending order\n * @return the same array if null/empty/singleton; otherwise a new sorted array\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) return array;\n    final int n \u003d array.length;\n    final int[] a \u003d array.clone();\n    final int THRESHOLD \u003d 24;\n    final int[] stack \u003d new int[128];\n    int sp \u003d 0;\n    stack[sp++] \u003d 0;\n    stack[sp++] \u003d n - 1;\n    while (sp \u003e 0) {\n        int hi \u003d stack[--sp];\n        int lo \u003d stack[--sp];\n        while (hi - lo + 1 \u003e THRESHOLD) {\n            int l \u003d lo, r \u003d hi, m \u003d (l + r) \u003e\u003e\u003e 1;\n            if (asc) {\n                if (a[l] \u003e a[m]) { int t \u003d a[l]; a[l] \u003d a[m]; a[m] \u003d t; }\n                if (a[l] \u003e a[r]) { int t \u003d a[l]; a[l] \u003d a[r]; a[r] \u003d t; }\n                if (a[m] \u003e a[r]) { int t \u003d a[m]; a[m] \u003d a[r]; a[r] \u003d t; }\n            } else {\n                if (a[l] \u003c a[m]) { int t \u003d a[l]; a[l] \u003d a[m]; a[m] \u003d t; }\n                if (a[l] \u003c a[r]) { int t \u003d a[l]; a[l] \u003d a[r]; a[r] \u003d t; }\n                if (a[m] \u003c a[r]) { int t \u003d a[m]; a[m] \u003d a[r]; a[r] \u003d t; }\n            }\n            int pivot \u003d a[m];\n            int lt \u003d lo, i \u003d lo, gt \u003d hi;\n            if (asc) {\n                while (i \u003c\u003d gt) {\n                    int v \u003d a[i];\n                    if (v \u003c pivot) {\n                        int t \u003d a[lt]; a[lt] \u003d v; a[i] \u003d t; lt++; i++;\n                    } else if (v \u003e pivot) {\n                        int t \u003d a[gt]; a[gt] \u003d v; a[i] \u003d t; gt--;\n                    } else {\n                        i++;\n                    }\n                }\n            } else {\n                while (i \u003c\u003d gt) {\n                    int v \u003d a[i];\n                    if (v \u003e pivot) {\n                        int t \u003d a[lt]; a[lt] \u003d v; a[i] \u003d t; lt++; i++;\n                    } else if (v \u003c pivot) {\n                        int t \u003d a[gt]; a[gt] \u003d v; a[i] \u003d t; gt--;\n                    } else {\n                        i++;\n                    }\n                }\n            }\n            int leftLo \u003d lo, leftHi \u003d lt - 1;\n            int rightLo \u003d gt + 1, rightHi \u003d hi;\n            int leftSize \u003d leftHi - leftLo + 1;\n            int rightSize \u003d rightHi - rightLo + 1;\n            if (leftSize \u003c rightSize) {\n                if (rightSize \u003e 0) { stack[sp++] \u003d rightLo; stack[sp++] \u003d rightHi; }\n                hi \u003d leftHi; lo \u003d leftLo;\n            } else {\n                if (leftSize \u003e 0) { stack[sp++] \u003d leftLo; stack[sp++] \u003d leftHi; }\n                lo \u003d rightLo; hi \u003d rightHi;\n            }\n        }\n        if (lo \u003c hi) {\n            for (int i \u003d lo + 1; i \u003c\u003d hi; i++) {\n                int v \u003d a[i];\n                int j \u003d i - 1;\n                if (asc) {\n                    while (j \u003e\u003d lo \u0026\u0026 a[j] \u003e v) { a[j + 1] \u003d a[j]; j--; }\n                } else {\n                    while (j \u003e\u003d lo \u0026\u0026 a[j] \u003c v) { a[j + 1] \u003d a[j]; j--; }\n                }\n                a[j + 1] \u003d v;\n            }\n        }\n    }\n    return a;\n}",
    "sinceUse": 0
  }
]