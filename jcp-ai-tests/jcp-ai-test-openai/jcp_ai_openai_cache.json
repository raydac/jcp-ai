[
  {
    "instant": "2025-08-20T05:10:19.377543838Z",
    "key": "JwczFQkRi2Zg3xhUyf6W/AmYQ5kcV3uURwixbOrhl4LoEObCv8opaLuXOUNjbRhs78yzYjPOca09mfWrmFGRzXVafnmW4+ZJMFHIWynJd+0\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts the given int array using a high-performance, low-overhead hybrid of iterative quicksort\n * (median-of-three, non-recursive, small-partition optimization) and insertion sort. Returns the\n * same array reference if it is null, empty, or has a single element; otherwise returns a new\n * array containing the sorted values in ascending order if asc is true, or descending order if false.\n *\n * @param array the array to sort\n * @param asc true for ascending order, false for descending\n * @return the same array if null/empty/singleton; otherwise a new array with sorted values\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c 2) return array;\n    final int n \u003d array.length;\n    final int[] a \u003d new int[n];\n    for (int i \u003d 0; i \u003c n; i++) a[i] \u003d array[i];\n    final int[] stack \u003d new int[128];\n    int sp \u003d 0;\n    stack[sp++] \u003d 0;\n    stack[sp++] \u003d n - 1;\n    while (sp \u003e 0) {\n        int hi \u003d stack[--sp];\n        int lo \u003d stack[--sp];\n        while (hi - lo \u003e 16) {\n            int mid \u003d lo + ((hi - lo) \u003e\u003e\u003e 1);\n            int p1 \u003d a[lo], p2 \u003d a[mid], p3 \u003d a[hi];\n            int pivot;\n            if (p1 \u003c p2) {\n                if (p2 \u003c p3) pivot \u003d p2;\n                else if (p1 \u003c p3) pivot \u003d p3;\n                else pivot \u003d p1;\n            } else {\n                if (p1 \u003c p3) pivot \u003d p1;\n                else if (p2 \u003c p3) pivot \u003d p3;\n                else pivot \u003d p2;\n            }\n            int i \u003d lo - 1, j \u003d hi + 1;\n            while (true) {\n                do { i++; } while (a[i] \u003c pivot);\n                do { j--; } while (a[j] \u003e pivot);\n                if (i \u003e\u003d j) {\n                    int leftLo \u003d lo, leftHi \u003d j, rightLo \u003d j + 1, rightHi \u003d hi;\n                    if (leftHi - leftLo \u003c rightHi - rightLo) {\n                        if (rightLo \u003c rightHi) { stack[sp++] \u003d rightLo; stack[sp++] \u003d rightHi; }\n                        lo \u003d leftLo; hi \u003d leftHi;\n                    } else {\n                        if (leftLo \u003c leftHi) { stack[sp++] \u003d leftLo; stack[sp++] \u003d leftHi; }\n                        lo \u003d rightLo; hi \u003d rightHi;\n                    }\n                    break;\n                }\n                int t \u003d a[i]; a[i] \u003d a[j]; a[j] \u003d t;\n            }\n        }\n        for (int i \u003d lo + 1; i \u003c\u003d hi; i++) {\n            int v \u003d a[i];\n            int j \u003d i - 1;\n            while (j \u003e\u003d lo \u0026\u0026 a[j] \u003e v) {\n                a[j + 1] \u003d a[j];\n                j--;\n            }\n            a[j + 1] \u003d v;\n        }\n    }\n    if (!asc) {\n        int i \u003d 0, j \u003d n - 1;\n        while (i \u003c j) {\n            int t \u003d a[i]; a[i] \u003d a[j]; a[j] \u003d t;\n            i++; j--;\n        }\n    }\n    return a;\n}",
    "sinceUse": 0
  }
]