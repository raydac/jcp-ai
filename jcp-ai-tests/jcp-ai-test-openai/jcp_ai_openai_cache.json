[{
  "instant": "2025-08-09T17:22:03.487830793Z",
  "key": "JwczFQkRi2Zg3xhUyf6W/AmYQ5kcV3uURwixbOrhl4LoEObCv8opaLuXOUNjbRhs78yzYjPOca09mfWrmFGRzXVafnmW4+ZJMFHIWynJd+0=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts the given int array using an iterative hybrid 3-way quicksort with insertion sort for small partitions.\n * Returns the same reference if the array is null, empty, or contains a single element; otherwise returns a new array\n * with the values sorted in ascending order when asc is true, or descending order when asc is false.\n * This implementation avoids recursion, minimizes auxiliary memory, and does not rely on external libraries.\n *\n * @param array the array to sort\n * @param asc true for ascending order, false for descending order\n * @return the original array if null or length < 2, otherwise a new array containing the sorted values\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array == null || array.length < 2) return array;\n    final int n = array.length;\n    final int[] a = new int[n];\n    for (int i = 0; i < n; i++) a[i] = array[i];\n    final int threshold = 24;\n    int l = 0, r = n - 1;\n    int maxDepth = Math.max(2, 2 * (32 - java.lang.Integer.numberOfLeadingZeros(n)));\n    int[] ls = new int[maxDepth];\n    int[] rs = new int[maxDepth];\n    int sp = 0;\n    while (true) {\n        if (r - l + 1 <= threshold) {\n            for (int i = l + 1; i <= r; i++) {\n                int v = a[i];\n                int j = i - 1;\n                while (j >= l && a[j] > v) {\n                    a[j + 1] = a[j];\n                    j--;\n                }\n                a[j + 1] = v;\n            }\n            if (sp == 0) break;\n            sp--;\n            l = ls[sp];\n            r = rs[sp];\n            continue;\n        }\n        int mid = l + ((r - l) >>> 1);\n        if (a[l] > a[mid]) { int t = a[l]; a[l] = a[mid]; a[mid] = t; }\n        if (a[l] > a[r]) { int t = a[l]; a[l] = a[r]; a[r] = t; }\n        if (a[mid] > a[r]) { int t = a[mid]; a[mid] = a[r]; a[r] = t; }\n        int pivot = a[mid];\n        int lt = l, i = l, gt = r;\n        while (i <= gt) {\n            int ai = a[i];\n            if (ai < pivot) { int t = a[lt]; a[lt] = ai; a[i] = t; lt++; i++; }\n            else if (ai > pivot) { int t = a[gt]; a[gt] = ai; a[i] = t; gt--; }\n            else { i++; }\n        }\n        int leftL = l, leftR = lt - 1;\n        int rightL = gt + 1, rightR = r;\n        int leftSize = leftR - leftL + 1;\n        int rightSize = rightR - rightL + 1;\n        if (leftSize > 0 && rightSize > 0) {\n            if (leftSize < rightSize) {\n                ls[sp] = leftL; rs[sp] = leftR; sp++;\n                l = rightL; r = rightR;\n            } else {\n                ls[sp] = rightL; rs[sp] = rightR; sp++;\n                l = leftL; r = leftR;\n            }\n        } else if (leftSize > 0) {\n            l = leftL; r = leftR;\n        } else if (rightSize > 0) {\n            l = rightL; r = rightR;\n        } else {\n            if (sp == 0) break;\n            sp--;\n            l = ls[sp];\n            r = rs[sp];\n        }\n    }\n    if (!asc) {\n        for (int i = 0, j = n - 1; i < j; i++, j--) {\n            int t = a[i]; a[i] = a[j]; a[j] = t;\n        }\n    }\n    return a;\n}",
  "sinceUse": 0
}]