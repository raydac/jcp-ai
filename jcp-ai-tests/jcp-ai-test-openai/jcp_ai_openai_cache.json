[{
  "uuid": "93fa228b-470e-4b56-95e4-eeb8735a8620",
  "instant": "2025-08-01T06:17:50.654157808Z",
  "key": "tBeMqvVnM5QcBjUZ/+TxUZ6Fl+/Mojpm7a+Nw6rseeIua7lxs8DAJtOsc4M7um0lgBrmDWVfckUOuhfeVo2rLvc7R4KnHfmNwLY/CnFovNs=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts the given int array using in-place dual-pivot quicksort for maximal performance and minimal memory overhead.\n * If the array is null, empty, or has only one element, the original array is returned.\n * The sorting is done in ascending order if asc == true, or descending order otherwise.\n * The method returns a new array containing sorted values without modifying the original.\n * No library sorting methods, helpers, or utility classes are used.\n *\n * @param array the int array to sort\n * @param asc true for ascending result, false for descending\n * @return a new sorted int array in specified order, or the original if null, empty, or singleton\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array == null || array.length <= 1) return array;\n    final int[] a = java.util.Arrays.copyOf(array, array.length);\n    final int n = a.length;\n    java.util.ArrayDeque<int[]> stack = new java.util.ArrayDeque<>();\n    stack.push(new int[]{0, n - 1});\n    while (!stack.isEmpty()) {\n        int[] r = stack.pop();\n        int left = r[0], right = r[1];\n        while (left < right) {\n            int lp = left, rp = right, p1 = a[left], p2 = a[right];\n            if ((asc && p1 > p2) || (!asc && p1 < p2)) {\n                int t = p1; p1 = p2; p2 = t;\n                a[left] = p1; a[right] = p2;\n            }\n            int i = left + 1, gt = right - 1, k = i;\n            while (k <= gt) {\n                int v = a[k];\n                if ((asc && v < p1) || (!asc && v > p1)) {\n                    a[k] = a[i]; a[i++] = v;\n                } else if ((asc && v > p2) || (!asc && v < p2)) {\n                    while ((asc && a[gt] > p2) || (!asc && a[gt] < p2)) {\n                        if (gt-- <= k) break;\n                    }\n                    int tv = a[k];\n                    a[k] = a[gt]; a[gt--] = tv;\n                    if ((asc && a[k] < p1) || (!asc && a[k] > p1)) {\n                        int ts = a[k];\n                        a[k] = a[i]; a[i++] = ts;\n                    }\n                }\n                k++;\n            }\n            a[left] = a[i - 1]; a[i - 1] = p1;\n            a[right] = a[gt + 1]; a[gt + 1] = p2;\n            int lsz = i - left - 1, msz = gt - i + 2, rsz = right - gt - 1;\n            if (lsz > 32) stack.push(new int[]{left, i - 2});\n            else if (lsz > 1) {\n                for (int m = left + 1; m < i - 1; m++) {\n                    int key = a[m], j = m - 1;\n                    while (j >= left && ((asc && a[j] > key) || (!asc && a[j] < key))) a[j + 1] = a[j--];\n                    a[j + 1] = key;\n                }\n            }\n            if (msz > 32) stack.push(new int[]{i, gt});\n            else if (msz > 1) {\n                for (int m = i + 1; m <= gt; m++) {\n                    int key = a[m], j = m - 1;\n                    while (j >= i && ((asc && a[j] > key) || (!asc && a[j] < key))) a[j + 1] = a[j--];\n                    a[j + 1] = key;\n                }\n            }\n            left = gt + 2;\n        }\n    }\n    return a;\n}",
  "sinceUse": 0
}]