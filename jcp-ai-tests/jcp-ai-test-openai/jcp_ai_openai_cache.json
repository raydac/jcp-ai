[
  {
    "instant": "2025-08-13T16:34:35.913306194Z",
    "key": "JwczFQkRi2Zg3xhUyf6W/AmYQ5kcV3uURwixbOrhl4LoEObCv8opaLuXOUNjbRhs78yzYjPOca09mfWrmFGRzXVafnmW4+ZJMFHIWynJd+0\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts the given int array using a high-performance, low-overhead algorithm.\n * Returns the same array if it is null, empty, or has a single element; otherwise returns a new sorted array.\n * Sorting is ascending when asc is true, descending otherwise.\n *\n * @param array the array to sort\n * @param asc true for ascending order, false for descending\n * @return the same array if length \u003c 2, otherwise a new array with sorted values\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null) return null;\n    final int n \u003d array.length;\n    if (n \u003c 2) return array;\n    final int[] a \u003d new int[n];\n    for (int i \u003d 0; i \u003c n; i++) a[i] \u003d array[i];\n    final int threshold \u003d 16;\n    int lo \u003d 0, hi \u003d n - 1;\n    int[] lStack \u003d new int[64], rStack \u003d new int[64], dStack \u003d new int[64];\n    int top \u003d 0;\n    int depthLimit \u003d 2 * (31 - Integer.numberOfLeadingZeros(n));\n    while (true) {\n        while (hi - lo + 1 \u003e threshold) {\n            if (depthLimit \u003d\u003d 0) {\n                int len \u003d hi - lo + 1;\n                for (int i \u003d (len \u003e\u003e\u003e 1) - 1; i \u003e\u003d 0; i--) {\n                    int parent \u003d i;\n                    int v \u003d a[lo + parent];\n                    int child;\n                    while ((child \u003d (parent \u003c\u003c 1) + 1) \u003c len) {\n                        int right \u003d child + 1;\n                        int c \u003d lo + child;\n                        if (right \u003c len \u0026\u0026 a[lo + right] \u003e a[c]) c \u003d lo + right;\n                        if (a[c] \u003c\u003d v) break;\n                        a[lo + parent] \u003d a[c];\n                        parent \u003d (c - lo);\n                    }\n                    a[lo + parent] \u003d v;\n                }\n                for (int end \u003d len - 1; end \u003e 0; end--) {\n                    int tmp \u003d a[lo];\n                    a[lo] \u003d a[lo + end];\n                    a[lo + end] \u003d tmp;\n                    int parent \u003d 0;\n                    int v \u003d a[lo];\n                    int child;\n                    while ((child \u003d (parent \u003c\u003c 1) + 1) \u003c end) {\n                        int right \u003d child + 1;\n                        int c \u003d lo + child;\n                        if (right \u003c end \u0026\u0026 a[lo + right] \u003e a[c]) c \u003d lo + right;\n                        if (a[c] \u003c\u003d v) break;\n                        a[lo + parent] \u003d a[c];\n                        parent \u003d (c - lo);\n                    }\n                    a[lo + parent] \u003d v;\n                }\n                hi \u003d lo;\n                break;\n            }\n            depthLimit--;\n            int mid \u003d (lo + hi) \u003e\u003e\u003e 1;\n            int x \u003d a[lo], y \u003d a[mid], z \u003d a[hi];\n            int pivot;\n            if (x \u003c y) {\n                if (y \u003c z) pivot \u003d y;\n                else if (x \u003c z) pivot \u003d z;\n                else pivot \u003d x;\n            } else {\n                if (x \u003c z) pivot \u003d x;\n                else if (y \u003c z) pivot \u003d z;\n                else pivot \u003d y;\n            }\n            int i \u003d lo - 1, j \u003d hi + 1;\n            while (true) {\n                do { i++; } while (a[i] \u003c pivot);\n                do { j--; } while (a[j] \u003e pivot);\n                if (i \u003e\u003d j) break;\n                int t \u003d a[i]; a[i] \u003d a[j]; a[j] \u003d t;\n            }\n            int leftLo \u003d lo, leftHi \u003d j, rightLo \u003d j + 1, rightHi \u003d hi;\n            if (leftHi - leftLo \u003e rightHi - rightLo) {\n                if (leftLo \u003c leftHi) { lStack[top] \u003d leftLo; rStack[top] \u003d leftHi; dStack[top] \u003d depthLimit; top++; }\n                lo \u003d rightLo; hi \u003d rightHi;\n            } else {\n                if (rightLo \u003c rightHi) { lStack[top] \u003d rightLo; rStack[top] \u003d rightHi; dStack[top] \u003d depthLimit; top++; }\n                lo \u003d leftLo; hi \u003d leftHi;\n            }\n        }\n        for (int i \u003d lo + 1; i \u003c\u003d hi; i++) {\n            int v \u003d a[i], j \u003d i - 1;\n            while (j \u003e\u003d lo \u0026\u0026 a[j] \u003e v) { a[j + 1] \u003d a[j]; j--; }\n            a[j + 1] \u003d v;\n        }\n        if (top \u003d\u003d 0) break;\n        top--;\n        lo \u003d lStack[top]; hi \u003d rStack[top]; depthLimit \u003d dStack[top];\n    }\n    if (!asc) {\n        for (int i \u003d 0, j \u003d n - 1; i \u003c j; i++, j--) {\n            int t \u003d a[i]; a[i] \u003d a[j]; a[j] \u003d t;\n        }\n    }\n    return a;\n}",
    "sinceUse": 0
  }
]