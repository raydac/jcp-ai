[{
  "uuid": "cff302d9-962b-4807-9268-ae43d9567e79",
  "instant": "2025-08-01T22:55:21.413863824Z",
  "key": "tBeMqvVnM5QcBjUZ/+TxUZ6Fl+/Mojpm7a+Nw6rseeIua7lxs8DAJtOsc4M7um0lgBrmDWVfckUOuhfeVo2rLvc7R4KnHfmNwLY/CnFovNs=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts an array of integers using in-place dual-pivot quicksort for speed and minimal memory overhead.\n * If the given array is null, empty, or has one element, returns the original array.\n * Otherwise, returns a new sorted array in ascending or descending order depending on the asc flag.\n * No external libraries or helper methods are used and the sort is implemented entirely in this method.\n * @param array the array to be sorted\n * @param asc true for ascending order, false for descending\n * @return a sorted array as specified, or the original if trivially sorted\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array == null || array.length < 2) return array;\n    int[] result = new int[array.length];\n    System.arraycopy(array, 0, result, 0, array.length);\n    int[] stack = new int[128];\n    int sp = 0;\n    stack[sp++] = 0;\n    stack[sp++] = result.length - 1;\n    java.util.Random rnd = new java.util.Random();\n    while (sp > 0) {\n        int right = stack[--sp];\n        int left = stack[--sp];\n        if (right - left < 27) {\n            for (int i = left + 1; i <= right; ++i) {\n                int t = result[i], j = i - 1;\n                while (j >= left && (asc ? result[j] > t : result[j] < t)) {\n                    result[j + 1] = result[j--];\n                }\n                result[j + 1] = t;\n            }\n            continue;\n        }\n        int p1 = left + rnd.nextInt(right - left + 1);\n        int p2 = left + rnd.nextInt(right - left + 1);\n        if (p1 == p2) p2 = left + (right - left) / 2;\n        int v1 = result[p1], v2 = result[p2];\n        if (asc ? v1 > v2 : v1 < v2) {\n            int tmp = v1; v1 = v2; v2 = tmp;\n            tmp = p1; p1 = p2; p2 = tmp;\n        }\n        int t = result[left]; result[left] = v1; result[p1] = t;\n        t = result[right]; result[right] = v2; result[p2] = t;\n        int l = left + 1, g = right - 1, k = l;\n        while (k <= g) {\n            if (asc ? result[k] < v1 : result[k] > v1) {\n                t = result[k]; result[k] = result[l]; result[l] = t;\n                ++l;\n            } else if (asc ? result[k] > v2 : result[k] < v2) {\n                while ((asc ? result[g] > v2 : result[g] < v2) && k < g) --g;\n                t = result[k]; result[k] = result[g]; result[g] = t;\n                --g;\n                if (asc ? result[k] < v1 : result[k] > v1) {\n                    t = result[k]; result[k] = result[l]; result[l] = t;\n                    ++l;\n                }\n            }\n            ++k;\n        }\n        --l; ++g;\n        t = result[left]; result[left] = result[l]; result[l] = t;\n        t = result[right]; result[right] = result[g]; result[g] = t;\n        if (left < l - 1) { stack[sp++] = left; stack[sp++] = l - 1; }\n        if (l + 1 < g - 1) { stack[sp++] = l + 1; stack[sp++] = g - 1; }\n        if (g + 1 < right) { stack[sp++] = g + 1; stack[sp++] = right; }\n        if (sp + 4 >= stack.length) {\n            int[] ns = new int[stack.length << 1];\n            System.arraycopy(stack, 0, ns, 0, sp);\n            stack = ns;\n        }\n    }\n    return result;\n}",
  "sinceUse": 0
}]