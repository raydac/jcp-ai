[
  {
    "instant": "2025-09-16T07:10:13.410970168Z",
    "key": "xSJc9S+tkUTe8REi08LfsXBzuUldeD9UjZucW1PC/A/tGfR/nE+zXqZnzr5Swm7V+1cvFUHskL+A3rd6e9yQISAFtrh83GSDiyTPrm52r9U\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts the given array of integers using a fast, memory-efficient algorithm.\n * Returns the same reference if the array is null, empty, or has a single element; otherwise returns a new sorted array.\n *\n * @param array the input array to sort\n * @param asc if true, sorts in ascending order; otherwise in descending order\n * @return the same array instance if null/empty/singleton, otherwise a new array with sorted values\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) return array;\n    final int[] a \u003d array.clone();\n    final int n \u003d a.length;\n    final int INSERTION_SORT_THRESHOLD \u003d 32;\n    int[] stackL \u003d new int[64];\n    int[] stackR \u003d new int[64];\n    int top \u003d 0;\n    stackL[top] \u003d 0;\n    stackR[top] \u003d n - 1;\n    top++;\n    if (asc) {\n        while (top \u003e 0) {\n            top--;\n            int l \u003d stackL[top];\n            int r \u003d stackR[top];\n            while (r - l \u003e INSERTION_SORT_THRESHOLD) {\n                int m \u003d (l + r) \u003e\u003e\u003e 1;\n                int x \u003d a[l], y \u003d a[m], z \u003d a[r];\n                if (y \u003c x) { a[l] \u003d y; a[m] \u003d x; x \u003d a[l]; y \u003d a[m]; }\n                if (z \u003c y) { a[m] \u003d z; a[r] \u003d y; y \u003d a[m]; z \u003d a[r]; }\n                if (y \u003c x) { a[l] \u003d y; a[m] \u003d x; x \u003d a[l]; y \u003d a[m]; }\n                int pivot \u003d y;\n                int i \u003d l, j \u003d r, p \u003d l, q \u003d r;\n                while (true) {\n                    while (a[i] \u003c pivot) i++;\n                    while (pivot \u003c a[j]) j--;\n                    if (i \u003e j) break;\n                    int tmp \u003d a[i]; a[i] \u003d a[j]; a[j] \u003d tmp;\n                    if (a[i] \u003d\u003d pivot) { int t \u003d a[p]; a[p] \u003d a[i]; a[i] \u003d t; p++; }\n                    if (a[j] \u003d\u003d pivot) { int t \u003d a[q]; a[q] \u003d a[j]; a[j] \u003d t; q--; }\n                    i++; j--;\n                }\n                for (int k \u003d l; k \u003c p; k++, j--) { int t \u003d a[k]; a[k] \u003d a[j]; a[j] \u003d t; }\n                for (int k \u003d r; k \u003e q; k--, i++) { int t \u003d a[k]; a[k] \u003d a[i]; a[i] \u003d t; }\n                int leftL \u003d l, leftR \u003d j, rightL \u003d i, rightR \u003d r;\n                if (leftR - leftL \u003e rightR - rightL) {\n                    if (leftL \u003c leftR) {\n                        if (top \u003d\u003d stackL.length) {\n                            int[] nl \u003d new int[stackL.length \u003c\u003c 1];\n                            int[] nr \u003d new int[stackR.length \u003c\u003c 1];\n                            java.lang.System.arraycopy(stackL, 0, nl, 0, top);\n                            java.lang.System.arraycopy(stackR, 0, nr, 0, top);\n                            stackL \u003d nl; stackR \u003d nr;\n                        }\n                        stackL[top] \u003d leftL; stackR[top] \u003d leftR; top++;\n                    }\n                    l \u003d rightL; r \u003d rightR;\n                } else {\n                    if (rightL \u003c rightR) {\n                        if (top \u003d\u003d stackL.length) {\n                            int[] nl \u003d new int[stackL.length \u003c\u003c 1];\n                            int[] nr \u003d new int[stackR.length \u003c\u003c 1];\n                            java.lang.System.arraycopy(stackL, 0, nl, 0, top);\n                            java.lang.System.arraycopy(stackR, 0, nr, 0, top);\n                            stackL \u003d nl; stackR \u003d nr;\n                        }\n                        stackL[top] \u003d rightL; stackR[top] \u003d rightR; top++;\n                    }\n                    l \u003d leftL; r \u003d leftR;\n                }\n            }\n        }\n        for (int i \u003d 1; i \u003c n; i++) {\n            int v \u003d a[i];\n            int j \u003d i - 1;\n            while (j \u003e\u003d 0 \u0026\u0026 a[j] \u003e v) { a[j + 1] \u003d a[j]; j--; }\n            a[j + 1] \u003d v;\n        }\n    } else {\n        while (top \u003e 0) {\n            top--;\n            int l \u003d stackL[top];\n            int r \u003d stackR[top];\n            while (r - l \u003e INSERTION_SORT_THRESHOLD) {\n                int m \u003d (l + r) \u003e\u003e\u003e 1;\n                int x \u003d a[l], y \u003d a[m], z \u003d a[r];\n                if (y \u003c x) { a[l] \u003d y; a[m] \u003d x; x \u003d a[l]; y \u003d a[m]; }\n                if (z \u003c y) { a[m] \u003d z; a[r] \u003d y; y \u003d a[m]; z \u003d a[r]; }\n                if (y \u003c x) { a[l] \u003d y; a[m] \u003d x; x \u003d a[l]; y \u003d a[m]; }\n                int pivot \u003d y;\n                int i \u003d l, j \u003d r, p \u003d l, q \u003d r;\n                while (true) {\n                    while (a[i] \u003e pivot) i++;\n                    while (pivot \u003e a[j]) j--;\n                    if (i \u003e j) break;\n                    int tmp \u003d a[i]; a[i] \u003d a[j]; a[j] \u003d tmp;\n                    if (a[i] \u003d\u003d pivot) { int t \u003d a[p]; a[p] \u003d a[i]; a[i] \u003d t; p++; }\n                    if (a[j] \u003d\u003d pivot) { int t \u003d a[q]; a[q] \u003d a[j]; a[j] \u003d t; q--; }\n                    i++; j--;\n                }\n                for (int k \u003d l; k \u003c p; k++, j--) { int t \u003d a[k]; a[k] \u003d a[j]; a[j] \u003d t; }\n                for (int k \u003d r; k \u003e q; k--, i++) { int t \u003d a[k]; a[k] \u003d a[i]; a[i] \u003d t; }\n                int leftL \u003d l, leftR \u003d j, rightL \u003d i, rightR \u003d r;\n                if (leftR - leftL \u003e rightR - rightL) {\n                    if (leftL \u003c leftR) {\n                        if (top \u003d\u003d stackL.length) {\n                            int[] nl \u003d new int[stackL.length \u003c\u003c 1];\n                            int[] nr \u003d new int[stackR.length \u003c\u003c 1];\n                            java.lang.System.arraycopy(stackL, 0, nl, 0, top);\n                            java.lang.System.arraycopy(stackR, 0, nr, 0, top);\n                            stackL \u003d nl; stackR \u003d nr;\n                        }\n                        stackL[top] \u003d leftL; stackR[top] \u003d leftR; top++;\n                    }\n                    l \u003d rightL; r \u003d rightR;\n                } else {\n                    if (rightL \u003c rightR) {\n                        if (top \u003d\u003d stackL.length) {\n                            int[] nl \u003d new int[stackL.length \u003c\u003c 1];\n                            int[] nr \u003d new int[stackR.length \u003c\u003c 1];\n                            java.lang.System.arraycopy(stackL, 0, nl, 0, top);\n                            java.lang.System.arraycopy(stackR, 0, nr, 0, top);\n                            stackL \u003d nl; stackR \u003d nr;\n                        }\n                        stackL[top] \u003d rightL; stackR[top] \u003d rightR; top++;\n                    }\n                    l \u003d leftL; r \u003d leftR;\n                }\n            }\n        }\n        for (int i \u003d 1; i \u003c n; i++) {\n            int v \u003d a[i];\n            int j \u003d i - 1;\n            while (j \u003e\u003d 0 \u0026\u0026 a[j] \u003c v) { a[j + 1] \u003d a[j]; j--; }\n            a[j + 1] \u003d v;\n        }\n    }\n    return a;\n}",
    "sinceUse": 0
  }
]