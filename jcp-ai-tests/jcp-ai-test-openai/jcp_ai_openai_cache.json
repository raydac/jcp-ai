[
  {
    "instant": "2025-09-12T22:09:39.105880264Z",
    "key": "xSJc9S+tkUTe8REi08LfsXBzuUldeD9UjZucW1PC/A/tGfR/nE+zXqZnzr5Swm7V+1cvFUHskL+A3rd6e9yQISAFtrh83GSDiyTPrm52r9U\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts the provided array of integers with priority on speed and minimal memory overhead.\n * If the input array is null, empty, or has a single element, the same reference is returned.\n * Otherwise, a cloned copy of the array is sorted and returned. Ascending or descending order\n * is controlled by the asc flag. The algorithm is a non-recursive quicksort with median-of-three\n * pivot selection and a final insertion sort pass to efficiently handle small partitions.\n *\n * @param array the array to be sorted\n * @param asc true for ascending order; false for descending order\n * @return the same array if it is null or has length \u003c\u003d 1; otherwise a new array with sorted values\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c\u003d 1) return array;\n    final int[] a \u003d array.clone();\n    final int n \u003d a.length;\n    final int TH \u003d 16;\n    if (asc) {\n        int[] ls \u003d new int[64];\n        int[] rs \u003d new int[64];\n        int sp \u003d 0;\n        int lo \u003d 0;\n        int hi \u003d n - 1;\n        while (true) {\n            while (hi - lo \u003e TH) {\n                int mid \u003d (lo + hi) \u003e\u003e\u003e 1;\n                int x \u003d a[lo], y \u003d a[mid], z \u003d a[hi];\n                int p \u003d x \u003c y ? (y \u003c z ? y : (x \u003c z ? z : x)) : (x \u003c z ? x : (y \u003c z ? z : y));\n                int i \u003d lo - 1;\n                int j \u003d hi + 1;\n                while (true) {\n                    do { i++; } while (a[i] \u003c p);\n                    do { j--; } while (a[j] \u003e p);\n                    if (i \u003e\u003d j) break;\n                    int t \u003d a[i]; a[i] \u003d a[j]; a[j] \u003d t;\n                }\n                if (j - lo \u003c hi - (j + 1)) {\n                    if (j - lo \u003e TH) { ls[sp] \u003d lo; rs[sp] \u003d j; sp++; }\n                    lo \u003d j + 1;\n                } else {\n                    if (hi - (j + 1) \u003e TH) { ls[sp] \u003d j + 1; rs[sp] \u003d hi; sp++; }\n                    hi \u003d j;\n                }\n            }\n            if (sp \u003d\u003d 0) break;\n            sp--;\n            lo \u003d ls[sp];\n            hi \u003d rs[sp];\n        }\n        for (int i \u003d 1; i \u003c n; i++) {\n            int v \u003d a[i];\n            int j \u003d i - 1;\n            while (j \u003e\u003d 0 \u0026\u0026 a[j] \u003e v) {\n                a[j + 1] \u003d a[j];\n                j--;\n            }\n            a[j + 1] \u003d v;\n        }\n    } else {\n        int[] ls \u003d new int[64];\n        int[] rs \u003d new int[64];\n        int sp \u003d 0;\n        int lo \u003d 0;\n        int hi \u003d n - 1;\n        while (true) {\n            while (hi - lo \u003e TH) {\n                int mid \u003d (lo + hi) \u003e\u003e\u003e 1;\n                int x \u003d a[lo], y \u003d a[mid], z \u003d a[hi];\n                int p \u003d x \u003c y ? (y \u003c z ? y : (x \u003c z ? z : x)) : (x \u003c z ? x : (y \u003c z ? z : y));\n                int i \u003d lo - 1;\n                int j \u003d hi + 1;\n                while (true) {\n                    do { i++; } while (a[i] \u003e p);\n                    do { j--; } while (a[j] \u003c p);\n                    if (i \u003e\u003d j) break;\n                    int t \u003d a[i]; a[i] \u003d a[j]; a[j] \u003d t;\n                }\n                if (j - lo \u003c hi - (j + 1)) {\n                    if (j - lo \u003e TH) { ls[sp] \u003d lo; rs[sp] \u003d j; sp++; }\n                    lo \u003d j + 1;\n                } else {\n                    if (hi - (j + 1) \u003e TH) { ls[sp] \u003d j + 1; rs[sp] \u003d hi; sp++; }\n                    hi \u003d j;\n                }\n            }\n            if (sp \u003d\u003d 0) break;\n            sp--;\n            lo \u003d ls[sp];\n            hi \u003d rs[sp];\n        }\n        for (int i \u003d 1; i \u003c n; i++) {\n            int v \u003d a[i];\n            int j \u003d i - 1;\n            while (j \u003e\u003d 0 \u0026\u0026 a[j] \u003c v) {\n                a[j + 1] \u003d a[j];\n                j--;\n            }\n            a[j + 1] \u003d v;\n        }\n    }\n    return a;\n}",
    "sinceUse": 0
  }
]