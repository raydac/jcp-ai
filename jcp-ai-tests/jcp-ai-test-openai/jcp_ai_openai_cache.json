[{
  "uuid": "64265bca-75d6-4f40-8294-3486635ed977",
  "instant": "2025-08-09T05:54:19.474203933Z",
  "key": "JwczFQkRi2Zg3xhUyf6W/AmYQ5kcV3uURwixbOrhl4LoEObCv8opaLuXOUNjbRhs78yzYjPOca09mfWrmFGRzXVafnmW4+ZJMFHIWynJd+0=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts the given int array using a fast, low-overhead hybrid quicksort (median-of-three pivot, iterative, with insertion sort on small segments).\n * Returns the same array instance if it is null, empty, or contains a single element; otherwise returns a new array with sorted values.\n *\n * @param array the array to be sorted\n * @param asc   true for ascending order, false for descending order\n * @return the same incoming array if null, empty, or single-element; otherwise a new array containing the sorted values\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array == null || array.length < 2) return array;\n    final int[] a = array.clone();\n    final int n = a.length;\n    final int THRESHOLD = 32;\n    final int[] lstack = new int[64];\n    final int[] rstack = new int[64];\n    int top = 0;\n    lstack[0] = 0;\n    rstack[0] = n - 1;\n    if (asc) {\n        while (top >= 0) {\n            int left = lstack[top];\n            int right = rstack[top];\n            top--;\n            while (right - left + 1 > THRESHOLD) {\n                int mid = left + ((right - left) >>> 1);\n                int x = a[left], y = a[mid], z = a[right];\n                int pivot = x < y ? (y < z ? y : (x < z ? z : x)) : (x < z ? x : (y < z ? z : y));\n                int i = left - 1;\n                int j = right + 1;\n                for (;;) {\n                    do { i++; } while (a[i] < pivot);\n                    do { j--; } while (a[j] > pivot);\n                    if (i >= j) break;\n                    int t = a[i]; a[i] = a[j]; a[j] = t;\n                }\n                if (j - left < right - j) {\n                    if (j + 1 <= right) { top++; lstack[top] = j + 1; rstack[top] = right; }\n                    right = j;\n                } else {\n                    if (left <= j) { top++; lstack[top] = left; rstack[top] = j; }\n                    left = j + 1;\n                }\n            }\n            for (int i = left + 1; i <= right; i++) {\n                int v = a[i];\n                int j = i - 1;\n                while (j >= left && a[j] > v) { a[j + 1] = a[j]; j--; }\n                a[j + 1] = v;\n            }\n        }\n    } else {\n        while (top >= 0) {\n            int left = lstack[top];\n            int right = rstack[top];\n            top--;\n            while (right - left + 1 > THRESHOLD) {\n                int mid = left + ((right - left) >>> 1);\n                int x = a[left], y = a[mid], z = a[right];\n                int pivot = x > y ? (y > z ? y : (x > z ? z : x)) : (x > z ? x : (y > z ? z : y));\n                int i = left - 1;\n                int j = right + 1;\n                for (;;) {\n                    do { i++; } while (a[i] > pivot);\n                    do { j--; } while (a[j] < pivot);\n                    if (i >= j) break;\n                    int t = a[i]; a[i] = a[j]; a[j] = t;\n                }\n                if (j - left < right - j) {\n                    if (j + 1 <= right) { top++; lstack[top] = j + 1; rstack[top] = right; }\n                    right = j;\n                } else {\n                    if (left <= j) { top++; lstack[top] = left; rstack[top] = j; }\n                    left = j + 1;\n                }\n            }\n            for (int i = left + 1; i <= right; i++) {\n                int v = a[i];\n                int j = i - 1;\n                while (j >= left && a[j] < v) { a[j + 1] = a[j]; j--; }\n                a[j + 1] = v;\n            }\n        }\n    }\n    return a;\n}",
  "sinceUse": 0
}]