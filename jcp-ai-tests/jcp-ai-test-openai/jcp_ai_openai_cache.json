[
  {
    "instant": "2025-09-04T06:19:01.495562378Z",
    "key": "JwczFQkRi2Zg3xhUyf6W/AmYQ5kcV3uURwixbOrhl4LoEObCv8opaLuXOUNjbRhs78yzYjPOca09mfWrmFGRzXVafnmW4+ZJMFHIWynJd+0\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts the given int array using an iterative quicksort with median-of-three pivot selection and a final insertion pass.\n * Returns the same array instance if it is null, empty, or contains a single element; otherwise returns a new array with sorted values.\n * Sorting is ascending when asc is true, descending otherwise. Implementation is standalone without external utilities.\n *\n * @param array the array to sort\n * @param asc true for ascending order, false for descending\n * @return the original array if null/size \u003c 2, otherwise a new sorted array\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null || array.length \u003c 2) return array;\n    final int n \u003d array.length;\n    final int[] a \u003d array.clone();\n    int l, r, i, j, m, pivot, tmp;\n    final int threshold \u003d 16;\n    final int[] stack \u003d new int[128];\n    int top \u003d 0;\n    stack[top++] \u003d 0;\n    stack[top++] \u003d n - 1;\n    while (top \u003e 0) {\n        r \u003d stack[--top];\n        l \u003d stack[--top];\n        while (r - l \u003e threshold) {\n            m \u003d (l + r) \u003e\u003e\u003e 1;\n            if (a[l] \u003e a[m]) { tmp \u003d a[l]; a[l] \u003d a[m]; a[m] \u003d tmp; }\n            if (a[m] \u003e a[r]) { tmp \u003d a[m]; a[m] \u003d a[r]; a[r] \u003d tmp; }\n            if (a[l] \u003e a[m]) { tmp \u003d a[l]; a[l] \u003d a[m]; a[m] \u003d tmp; }\n            pivot \u003d a[m];\n            i \u003d l;\n            j \u003d r;\n            while (true) {\n                while (a[i] \u003c pivot) i++;\n                while (a[j] \u003e pivot) j--;\n                if (i \u003e j) break;\n                tmp \u003d a[i]; a[i] \u003d a[j]; a[j] \u003d tmp;\n                i++; j--;\n            }\n            if (j - l \u003c r - i) {\n                if (i \u003c r) { stack[top++] \u003d i; stack[top++] \u003d r; }\n                r \u003d j;\n            } else {\n                if (l \u003c j) { stack[top++] \u003d l; stack[top++] \u003d j; }\n                l \u003d i;\n            }\n        }\n    }\n    for (i \u003d 1; i \u003c n; i++) {\n        tmp \u003d a[i];\n        j \u003d i - 1;\n        while (j \u003e\u003d 0 \u0026\u0026 a[j] \u003e tmp) { a[j + 1] \u003d a[j]; j--; }\n        a[j + 1] \u003d tmp;\n    }\n    if (!asc) {\n        i \u003d 0; j \u003d n - 1;\n        while (i \u003c j) { tmp \u003d a[i]; a[i] \u003d a[j]; a[j] \u003d tmp; i++; j--; }\n    }\n    return a;\n}",
    "sinceUse": 0
  }
]