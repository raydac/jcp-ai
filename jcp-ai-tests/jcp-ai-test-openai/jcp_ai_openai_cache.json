[
  {
    "instant": "2025-09-09T10:33:47.054264378Z",
    "key": "JwczFQkRi2Zg3xhUyf6W/AmYQ5kcV3uURwixbOrhl4LoEObCv8opaLuXOUNjbRhs78yzYjPOca09mfWrmFGRzXVafnmW4+ZJMFHIWynJd+0\u003d",
    "fileName": "ArraySorter.java",
    "line": 6,
    "result": "/**\n * Sorts the given int array using a high-performance, low-overhead algorithm.\n * Returns the same array instance if it is null, empty, or has a single element; otherwise returns a new array containing the sorted values.\n * Ascending order is used when asc is true; descending order otherwise.\n * The implementation is self-contained, non-recursive (heapsort for large arrays) with an insertion sort fast path for small arrays.\n *\n * @param array the array to sort\n * @param asc true for ascending order, false for descending order\n * @return the original array when null or size \u003c 2, otherwise a new array with sorted values\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array \u003d\u003d null) return array;\n    final int n \u003d array.length;\n    if (n \u003c 2) return array;\n    final int[] a \u003d new int[n];\n    java.lang.System.arraycopy(array, 0, a, 0, n);\n    if (n \u003c 32) {\n        for (int i \u003d 1; i \u003c n; i++) {\n            int x \u003d a[i], j \u003d i - 1;\n            while (j \u003e\u003d 0 \u0026\u0026 a[j] \u003e x) {\n                a[j + 1] \u003d a[j];\n                j--;\n            }\n            a[j + 1] \u003d x;\n        }\n    } else {\n        for (int i \u003d (n \u003e\u003e\u003e 1) - 1; i \u003e\u003d 0; i--) {\n            int k \u003d i, v \u003d a[k], half \u003d n \u003e\u003e\u003e 1;\n            while (k \u003c half) {\n                int child \u003d (k \u003c\u003c 1) + 1, right \u003d child + 1;\n                int c \u003d (right \u003c n \u0026\u0026 a[child] \u003c a[right]) ? right : child;\n                if (v \u003e\u003d a[c]) break;\n                a[k] \u003d a[c];\n                k \u003d c;\n            }\n            a[k] \u003d v;\n        }\n        for (int end \u003d n - 1; end \u003e 0; end--) {\n            int v \u003d a[end];\n            a[end] \u003d a[0];\n            int k \u003d 0, half \u003d end \u003e\u003e\u003e 1;\n            while (k \u003c half) {\n                int child \u003d (k \u003c\u003c 1) + 1, right \u003d child + 1;\n                int c \u003d (right \u003c end \u0026\u0026 a[child] \u003c a[right]) ? right : child;\n                a[k] \u003d a[c];\n                k \u003d c;\n            }\n            a[k] \u003d v;\n            while (k \u003e 0) {\n                int p \u003d (k - 1) \u003e\u003e\u003e 1;\n                if (a[p] \u003e\u003d a[k]) break;\n                int t \u003d a[k]; a[k] \u003d a[p]; a[p] \u003d t;\n                k \u003d p;\n            }\n        }\n    }\n    if (!asc) {\n        for (int l \u003d 0, r \u003d n - 1; l \u003c r; l++, r--) {\n            int t \u003d a[l]; a[l] \u003d a[r]; a[r] \u003d t;\n        }\n    }\n    return a;\n}",
    "sinceUse": 0
  }
]