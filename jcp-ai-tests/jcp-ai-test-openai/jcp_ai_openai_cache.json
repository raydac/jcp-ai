[{
  "uuid": "117ef4f9-54f7-4942-af48-d25a22e46eed",
  "instant": "2025-07-27T12:31:22.787911276Z",
  "key": "tBeMqvVnM5QcBjUZ/+TxUZ6Fl+/Mojpm7a+Nw6rseeIua7lxs8DAJtOsc4M7um0lgBrmDWVfckUOuhfeVo2rLvc7R4KnHfmNwLY/CnFovNs=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts the specified integer array in ascending or descending order using in-place dual-pivot quicksort algorithm.\n * Returns the same array if it is null, empty or has a single element, else returns a new array containing sorted elements.\n * Sorting is performed with minimal memory overhead and gives priority to speed.\n *\n * @param array the array to be sorted\n * @param asc true for ascending order, false for descending order\n * @return sorted array (new array if length > 1, else the original array)\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array == null || array.length < 2) return array;\n    final int n = array.length;\n    int[] result = new int[n];\n    for (int i = 0; i < n; ++i) result[i] = array[i];\n    java.util.Deque<int[]> stack = new java.util.ArrayDeque<>();\n    stack.push(new int[]{0, n - 1});\n    while (!stack.isEmpty()) {\n        int[] bounds = stack.pop();\n        int left = bounds[0], right = bounds[1];\n        if (left < right) {\n            int x = result[left], y = result[right];\n            if ((asc && x > y) || (!asc && x < y)) {\n                int tmp = result[left]; result[left] = result[right]; result[right] = tmp;\n                x = result[left]; y = result[right];\n            }\n            int p = x, q = y;\n            int i = left + 1, lt = left + 1, gt = right - 1;\n            while (i <= gt) {\n                int v = result[i];\n                if ((asc && v < p) || (!asc && v > p)) {\n                    int tmp = result[lt]; result[lt] = result[i]; result[i] = tmp;\n                    ++lt; ++i;\n                } else if ((asc && v > q) || (!asc && v < q)) {\n                    int tmp = result[gt]; result[gt] = result[i]; result[i] = tmp;\n                    --gt;\n                } else {\n                    ++i;\n                }\n            }\n            --lt; ++gt;\n            int tmp = result[left]; result[left] = result[lt]; result[lt] = tmp;\n            tmp = result[right]; result[right] = result[gt]; result[gt] = tmp;\n            stack.push(new int[]{left, lt - 1});\n            stack.push(new int[]{lt + 1, gt - 1});\n            stack.push(new int[]{gt + 1, right});\n        }\n    }\n    return result;\n}",
  "sinceUse": 0
}]