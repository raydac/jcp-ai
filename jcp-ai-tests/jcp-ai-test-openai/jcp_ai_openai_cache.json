[{
  "uuid": "08f6a5b0-ba25-4b4f-b167-24960c88c25a",
  "instant": "2025-08-02T07:56:54.580082846Z",
  "key": "LLl+r7Sgd1BvhNKjtf4PGkBbzoRY7c5eDHPoRCD1zuDV68jdusSkiBtrTWrAPTvjedPzwCkpfDVaTUhNT+SFfcdcm2TOkkp56g+ENzuqi6c=",
  "fileName": "ArraySorter.java",
  "line": 6,
  "result": "/**\n * Sorts the given integer array in ascending or descending order using an in-place dual-pivot quicksort algorithm for highest speed and minimal memory overhead.\n * Returns the original array if it is null, empty or contains a single element; otherwise, returns a new sorted array.\n *\n * @param array the array to sort\n * @param asc true for ascending sort, false for descending order\n * @return a sorted array, or the original if null, empty or single element\n */\npublic static int[] fastSort(final int[] array, final boolean asc) {\n    if (array == null || array.length <= 1) return array;\n    int[] a = new int[array.length];\n    System.arraycopy(array, 0, a, 0, array.length);\n    final java.util.Random rnd = new java.util.Random();\n    final int dir = asc ? 1 : -1;\n    int left = 0, right = a.length - 1;\n    java.util.ArrayDeque<int[]> stack = new java.util.ArrayDeque<>();\n    stack.push(new int[]{left, right});\n    while (!stack.isEmpty()) {\n        int[] bounds = stack.pop();\n        left = bounds[0];\n        right = bounds[1];\n        if (left >= right) continue;\n        int len = right - left + 1;\n        if (len < 17) {\n            for (int i = left + 1; i <= right; ++i) {\n                int x = a[i], j = i - 1;\n                while (j >= left && Integer.compare(a[j], x) * dir > 0) {\n                    a[j + 1] = a[j];\n                    --j;\n                }\n                a[j + 1] = x;\n            }\n            continue;\n        }\n        int idx1 = left + rnd.nextInt(len), idx2 = left + rnd.nextInt(len);\n        if (Integer.compare(a[idx1], a[idx2]) * dir > 0) {\n            int tmp = a[idx1]; a[idx1] = a[idx2]; a[idx2] = tmp;\n        }\n        int p = a[idx1], q = a[idx2];\n        a[idx1] = a[left]; a[left] = p;\n        a[idx2] = a[right]; a[right] = q;\n        int l = left + 1, g = right - 1, k = l;\n        while (k <= g) {\n            if (Integer.compare(a[k], p) * dir < 0) {\n                int tmp = a[k]; a[k] = a[l]; a[l] = tmp;\n                ++l;\n            } else if (Integer.compare(a[k], q) * dir > 0) {\n                while (k < g && Integer.compare(a[g], q) * dir > 0) --g;\n                int tmp = a[k]; a[k] = a[g]; a[g] = tmp;\n                --g;\n                if (Integer.compare(a[k], p) * dir < 0) {\n                    tmp = a[k]; a[k] = a[l]; a[l] = tmp;\n                    ++l;\n                }\n            }\n            ++k;\n        }\n        --l; ++g;\n        a[left] = a[l]; a[l] = p;\n        a[right] = a[g]; a[g] = q;\n        stack.push(new int[]{left, l - 1});\n        stack.push(new int[]{l + 1, g - 1});\n        stack.push(new int[]{g + 1, right});\n    }\n    return a;\n}",
  "sinceUse": 0
}]